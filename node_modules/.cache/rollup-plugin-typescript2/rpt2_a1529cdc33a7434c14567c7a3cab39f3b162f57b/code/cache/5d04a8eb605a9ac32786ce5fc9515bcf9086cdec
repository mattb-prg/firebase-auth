{"code":"/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { ErrorFactory } from '@firebase/util';\r\nimport { _DEFAULT_AUTH_ERROR_FACTORY, prodErrorMap } from '../errors';\r\nimport { _logError } from './log';\r\nexport function _fail(authOrCode, ...rest) {\r\n    throw createErrorInternal(authOrCode, ...rest);\r\n}\r\nexport function _createError(authOrCode, ...rest) {\r\n    return createErrorInternal(authOrCode, ...rest);\r\n}\r\nexport function _errorWithCustomMessage(auth, code, message) {\r\n    const errorMap = Object.assign(Object.assign({}, prodErrorMap()), { [code]: message });\r\n    const factory = new ErrorFactory('auth', 'Firebase', errorMap);\r\n    return factory.create(code, {\r\n        appName: auth.name\r\n    });\r\n}\r\nexport function _assertInstanceOf(auth, object, instance) {\r\n    const constructorInstance = instance;\r\n    if (!(object instanceof constructorInstance)) {\r\n        if (constructorInstance.name !== object.constructor.name) {\r\n            _fail(auth, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\r\n        }\r\n        throw _errorWithCustomMessage(auth, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */, `Type of ${object.constructor.name} does not match expected instance.` +\r\n            `Did you pass a reference from a different Auth SDK?`);\r\n    }\r\n}\r\nfunction createErrorInternal(authOrCode, ...rest) {\r\n    if (typeof authOrCode !== 'string') {\r\n        const code = rest[0];\r\n        const fullParams = [...rest.slice(1)];\r\n        if (fullParams[0]) {\r\n            fullParams[0].appName = authOrCode.name;\r\n        }\r\n        return authOrCode._errorFactory.create(code, ...fullParams);\r\n    }\r\n    return _DEFAULT_AUTH_ERROR_FACTORY.create(authOrCode, ...rest);\r\n}\r\nexport function _assert(assertion, authOrCode, ...rest) {\r\n    if (!assertion) {\r\n        throw createErrorInternal(authOrCode, ...rest);\r\n    }\r\n}\r\nclass Optional {\r\n    constructor(type) {\r\n        this.type = type;\r\n    }\r\n}\r\nexport function opt(type) {\r\n    return new Optional(type);\r\n}\r\n/**\r\n * Asserts the runtime types of arguments. The 'expected' field can be one of\r\n * a class, a string (representing a \"typeof\" call), or a record map of name\r\n * to type. Furthermore, the opt() function can be used to mark a field as\r\n * optional. For example:\r\n *\r\n * function foo(auth: Auth, profile: {displayName?: string}, update = false) {\r\n *   assertTypes(arguments, [AuthImpl, {displayName: opt('string')}, opt('boolean')]);\r\n * }\r\n *\r\n * opt() can be used for any type:\r\n * function foo(auth?: Auth) {\r\n *   assertTypes(arguments, [opt(AuthImpl)]);\r\n * }\r\n *\r\n * The string types can be or'd together, and you can use \"null\" as well (note\r\n * that typeof null === 'object'; this is an edge case). For example:\r\n *\r\n * function foo(profile: {displayName?: string | null}) {\r\n *   assertTypes(arguments, [{displayName: opt('string|null')}]);\r\n * }\r\n *\r\n * @param args\r\n * @param expected\r\n */\r\nexport function assertTypes(args, ...expected) {\r\n    if (args.length > expected.length) {\r\n        _fail(\"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */, {});\r\n    }\r\n    for (let i = 0; i < expected.length; i++) {\r\n        let expect = expected[i];\r\n        const arg = args[i];\r\n        if (expect instanceof Optional) {\r\n            // If the arg is undefined, then it matches \"optional\" and we can move to\r\n            // the next arg\r\n            if (typeof arg === 'undefined') {\r\n                continue;\r\n            }\r\n            expect = expect.type;\r\n        }\r\n        if (typeof expect === 'string') {\r\n            // Handle the edge case for null because typeof null === 'object'\r\n            if (expect.includes('null') && arg === null) {\r\n                continue;\r\n            }\r\n            const required = expect.split('|');\r\n            _assert(required.includes(typeof arg), \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */, {});\r\n        }\r\n        else if (typeof expect === 'object') {\r\n            // Recursively check record arguments\r\n            const record = arg;\r\n            const map = expect;\r\n            const keys = Object.keys(expect);\r\n            assertTypes(keys.map(k => record[k]), ...keys.map(k => map[k]));\r\n        }\r\n        else {\r\n            _assert(arg instanceof expect, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */, {});\r\n        }\r\n    }\r\n}\r\n/**\r\n * Unconditionally fails, throwing an internal error with the given message.\r\n *\r\n * @param failure type of failure encountered\r\n * @throws Error\r\n */\r\nexport function debugFail(failure) {\r\n    // Log the failure in addition to throw an exception, just in case the\r\n    // exception is swallowed.\r\n    const message = `INTERNAL ASSERTION FAILED: ` + failure;\r\n    _logError(message);\r\n    // NOTE: We don't use FirebaseError here because these are internal failures\r\n    // that cannot be handled by the user. (Also it would create a circular\r\n    // dependency between the error and assert modules which doesn't work.)\r\n    throw new Error(message);\r\n}\r\n/**\r\n * Fails if the given assertion condition is false, throwing an Error with the\r\n * given message if it did.\r\n *\r\n * @param assertion\r\n * @param message\r\n */\r\nexport function debugAssert(assertion, message) {\r\n    if (!assertion) {\r\n        debugFail(message);\r\n    }\r\n}\r\n//# sourceMappingURL=assert.js.map","references":["/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/model/public_types.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/util/dist/index.d.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/model/auth.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/core/errors.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/core/util/log.ts"],"map":"{\"version\":3,\"file\":\"assert.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../../src/core/util/assert.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/node_modules/.cache/rollup-plugin-typescript2/placeholder/src/core/util/assert.d.ts","writeByteOrderMark":false,"text":"/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { Auth } from '../../model/public_types';\r\nimport { FirebaseError } from '@firebase/util';\r\nimport { AuthErrorCode, AuthErrorParams } from '../errors';\r\ndeclare type LessAppName<K extends AuthErrorCode> = Omit<AuthErrorParams[K], 'appName'>;\r\n/**\r\n * Unconditionally fails, throwing a developer facing INTERNAL_ERROR\r\n *\r\n * @example\r\n * ```javascript\r\n * fail(auth, AuthErrorCode.MFA_REQUIRED);  // Error: the MFA_REQUIRED error needs more params than appName\r\n * fail(auth, AuthErrorCode.MFA_REQUIRED, {serverResponse});  // Compiles\r\n * fail(AuthErrorCode.INTERNAL_ERROR);  // Compiles; internal error does not need appName\r\n * fail(AuthErrorCode.USER_DELETED);  // Error: USER_DELETED requires app name\r\n * fail(auth, AuthErrorCode.USER_DELETED);  // Compiles; USER_DELETED _only_ needs app name\r\n * ```\r\n *\r\n * @param appName App name for tagging the error\r\n * @throws FirebaseError\r\n */\r\nexport declare function _fail<K extends AuthErrorCode>(code: K, ...data: {} extends AuthErrorParams[K] ? [AuthErrorParams[K]?] : [AuthErrorParams[K]]): never;\r\nexport declare function _fail<K extends AuthErrorCode>(auth: Auth, code: K, ...data: {} extends LessAppName<K> ? [LessAppName<K>?] : [LessAppName<K>]): never;\r\nexport declare function _createError<K extends AuthErrorCode>(code: K, ...data: {} extends AuthErrorParams[K] ? [AuthErrorParams[K]?] : [AuthErrorParams[K]]): FirebaseError;\r\nexport declare function _createError<K extends AuthErrorCode>(auth: Auth, code: K, ...data: {} extends LessAppName<K> ? [LessAppName<K>?] : [LessAppName<K>]): FirebaseError;\r\nexport declare function _errorWithCustomMessage(auth: Auth, code: AuthErrorCode, message: string): FirebaseError;\r\nexport declare function _assertInstanceOf(auth: Auth, object: object, instance: unknown): void;\r\nexport declare function _assert<K extends AuthErrorCode>(assertion: unknown, code: K, ...data: {} extends AuthErrorParams[K] ? [AuthErrorParams[K]?] : [AuthErrorParams[K]]): asserts assertion;\r\nexport declare function _assert<K extends AuthErrorCode>(assertion: unknown, auth: Auth, code: K, ...data: {} extends LessAppName<K> ? [LessAppName<K>?] : [LessAppName<K>]): asserts assertion;\r\ndeclare type TypeExpectation = Function | string | MapType;\r\ninterface MapType extends Record<string, TypeExpectation | Optional> {\r\n}\r\ndeclare class Optional {\r\n    readonly type: TypeExpectation;\r\n    constructor(type: TypeExpectation);\r\n}\r\nexport declare function opt(type: TypeExpectation): Optional;\r\n/**\r\n * Asserts the runtime types of arguments. The 'expected' field can be one of\r\n * a class, a string (representing a \"typeof\" call), or a record map of name\r\n * to type. Furthermore, the opt() function can be used to mark a field as\r\n * optional. For example:\r\n *\r\n * function foo(auth: Auth, profile: {displayName?: string}, update = false) {\r\n *   assertTypes(arguments, [AuthImpl, {displayName: opt('string')}, opt('boolean')]);\r\n * }\r\n *\r\n * opt() can be used for any type:\r\n * function foo(auth?: Auth) {\r\n *   assertTypes(arguments, [opt(AuthImpl)]);\r\n * }\r\n *\r\n * The string types can be or'd together, and you can use \"null\" as well (note\r\n * that typeof null === 'object'; this is an edge case). For example:\r\n *\r\n * function foo(profile: {displayName?: string | null}) {\r\n *   assertTypes(arguments, [{displayName: opt('string|null')}]);\r\n * }\r\n *\r\n * @param args\r\n * @param expected\r\n */\r\nexport declare function assertTypes(args: Omit<IArguments, 'callee'>, ...expected: Array<TypeExpectation | Optional>): void;\r\n/**\r\n * Unconditionally fails, throwing an internal error with the given message.\r\n *\r\n * @param failure type of failure encountered\r\n * @throws Error\r\n */\r\nexport declare function debugFail(failure: string): never;\r\n/**\r\n * Fails if the given assertion condition is false, throwing an Error with the\r\n * given message if it did.\r\n *\r\n * @param assertion\r\n * @param message\r\n */\r\nexport declare function debugAssert(assertion: unknown, message: string): asserts assertion;\r\nexport {};\r\n"}}
