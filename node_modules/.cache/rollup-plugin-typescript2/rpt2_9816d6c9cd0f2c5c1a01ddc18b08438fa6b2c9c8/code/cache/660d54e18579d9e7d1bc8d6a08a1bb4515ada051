{"code":"/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { __awaiter, __generator } from \"tslib\";\r\nimport { _allSettled } from './promise';\r\n/**\r\n * Interface class for receiving messages.\r\n *\r\n */\r\nvar Receiver = /** @class */ (function () {\r\n    function Receiver(eventTarget) {\r\n        this.eventTarget = eventTarget;\r\n        this.handlersMap = {};\r\n        this.boundEventHandler = this.handleEvent.bind(this);\r\n    }\r\n    /**\r\n     * Obtain an instance of a Receiver for a given event target, if none exists it will be created.\r\n     *\r\n     * @param eventTarget - An event target (such as window or self) through which the underlying\r\n     * messages will be received.\r\n     */\r\n    Receiver._getInstance = function (eventTarget) {\r\n        // The results are stored in an array since objects can't be keys for other\r\n        // objects. In addition, setting a unique property on an event target as a\r\n        // hash map key may not be allowed due to CORS restrictions.\r\n        var existingInstance = this.receivers.find(function (receiver) {\r\n            return receiver.isListeningto(eventTarget);\r\n        });\r\n        if (existingInstance) {\r\n            return existingInstance;\r\n        }\r\n        var newInstance = new Receiver(eventTarget);\r\n        this.receivers.push(newInstance);\r\n        return newInstance;\r\n    };\r\n    Receiver.prototype.isListeningto = function (eventTarget) {\r\n        return this.eventTarget === eventTarget;\r\n    };\r\n    /**\r\n     * Fans out a MessageEvent to the appropriate listeners.\r\n     *\r\n     * @remarks\r\n     * Sends an {@link Status.ACK} upon receipt and a {@link Status.DONE} once all handlers have\r\n     * finished processing.\r\n     *\r\n     * @param event - The MessageEvent.\r\n     *\r\n     */\r\n    Receiver.prototype.handleEvent = function (event) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var messageEvent, _a, eventId, eventType, data, handlers, promises, response;\r\n            var _this = this;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        messageEvent = event;\r\n                        _a = messageEvent.data, eventId = _a.eventId, eventType = _a.eventType, data = _a.data;\r\n                        handlers = this.handlersMap[eventType];\r\n                        if (!(handlers === null || handlers === void 0 ? void 0 : handlers.size)) {\r\n                            return [2 /*return*/];\r\n                        }\r\n                        messageEvent.ports[0].postMessage({\r\n                            status: \"ack\" /* _Status.ACK */,\r\n                            eventId: eventId,\r\n                            eventType: eventType\r\n                        });\r\n                        promises = Array.from(handlers).map(function (handler) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {\r\n                            return [2 /*return*/, handler(messageEvent.origin, data)];\r\n                        }); }); });\r\n                        return [4 /*yield*/, _allSettled(promises)];\r\n                    case 1:\r\n                        response = _b.sent();\r\n                        messageEvent.ports[0].postMessage({\r\n                            status: \"done\" /* _Status.DONE */,\r\n                            eventId: eventId,\r\n                            eventType: eventType,\r\n                            response: response\r\n                        });\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Subscribe an event handler for a particular event.\r\n     *\r\n     * @param eventType - Event name to subscribe to.\r\n     * @param eventHandler - The event handler which should receive the events.\r\n     *\r\n     */\r\n    Receiver.prototype._subscribe = function (eventType, eventHandler) {\r\n        if (Object.keys(this.handlersMap).length === 0) {\r\n            this.eventTarget.addEventListener('message', this.boundEventHandler);\r\n        }\r\n        if (!this.handlersMap[eventType]) {\r\n            this.handlersMap[eventType] = new Set();\r\n        }\r\n        this.handlersMap[eventType].add(eventHandler);\r\n    };\r\n    /**\r\n     * Unsubscribe an event handler from a particular event.\r\n     *\r\n     * @param eventType - Event name to unsubscribe from.\r\n     * @param eventHandler - Optinoal event handler, if none provided, unsubscribe all handlers on this event.\r\n     *\r\n     */\r\n    Receiver.prototype._unsubscribe = function (eventType, eventHandler) {\r\n        if (this.handlersMap[eventType] && eventHandler) {\r\n            this.handlersMap[eventType].delete(eventHandler);\r\n        }\r\n        if (!eventHandler || this.handlersMap[eventType].size === 0) {\r\n            delete this.handlersMap[eventType];\r\n        }\r\n        if (Object.keys(this.handlersMap).length === 0) {\r\n            this.eventTarget.removeEventListener('message', this.boundEventHandler);\r\n        }\r\n    };\r\n    Receiver.receivers = [];\r\n    return Receiver;\r\n}());\r\nexport { Receiver };\r\n//# sourceMappingURL=receiver.js.map","references":["/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/platform_browser/messagechannel/index.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/platform_browser/messagechannel/promise.ts"],"map":"{\"version\":3,\"file\":\"receiver.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../../src/platform_browser/messagechannel/receiver.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/node_modules/.cache/rollup-plugin-typescript2/placeholder/src/platform_browser/messagechannel/receiver.d.ts","writeByteOrderMark":false,"text":"/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { ReceiverHandler, _EventType, _ReceiverResponse, _SenderRequest } from './index';\r\n/**\r\n * Interface class for receiving messages.\r\n *\r\n */\r\nexport declare class Receiver {\r\n    private readonly eventTarget;\r\n    private static readonly receivers;\r\n    private readonly boundEventHandler;\r\n    private readonly handlersMap;\r\n    constructor(eventTarget: EventTarget);\r\n    /**\r\n     * Obtain an instance of a Receiver for a given event target, if none exists it will be created.\r\n     *\r\n     * @param eventTarget - An event target (such as window or self) through which the underlying\r\n     * messages will be received.\r\n     */\r\n    static _getInstance(eventTarget: EventTarget): Receiver;\r\n    private isListeningto;\r\n    /**\r\n     * Fans out a MessageEvent to the appropriate listeners.\r\n     *\r\n     * @remarks\r\n     * Sends an {@link Status.ACK} upon receipt and a {@link Status.DONE} once all handlers have\r\n     * finished processing.\r\n     *\r\n     * @param event - The MessageEvent.\r\n     *\r\n     */\r\n    private handleEvent;\r\n    /**\r\n     * Subscribe an event handler for a particular event.\r\n     *\r\n     * @param eventType - Event name to subscribe to.\r\n     * @param eventHandler - The event handler which should receive the events.\r\n     *\r\n     */\r\n    _subscribe<T extends _ReceiverResponse, S extends _SenderRequest>(eventType: _EventType, eventHandler: ReceiverHandler<T, S>): void;\r\n    /**\r\n     * Unsubscribe an event handler from a particular event.\r\n     *\r\n     * @param eventType - Event name to unsubscribe from.\r\n     * @param eventHandler - Optinoal event handler, if none provided, unsubscribe all handlers on this event.\r\n     *\r\n     */\r\n    _unsubscribe<T extends _ReceiverResponse, S extends _SenderRequest>(eventType: _EventType, eventHandler?: ReceiverHandler<T, S>): void;\r\n}\r\n"}}
