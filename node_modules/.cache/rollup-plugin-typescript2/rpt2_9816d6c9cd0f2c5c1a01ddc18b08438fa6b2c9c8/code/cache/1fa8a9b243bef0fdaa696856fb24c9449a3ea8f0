{"code":"/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nexport {};\r\n//# sourceMappingURL=public_types.js.map","references":["/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/app/dist/app/src/index.d.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/util/dist/index.d.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/model/enum_maps.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/component/dist/index.d.ts"],"map":"{\"version\":3,\"file\":\"public_types.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../src/model/public_types.ts\"],\"names\":[],\"mappings\":\"AAAA;;;;;;;;;;;;;;;GAeG\"}","dts":{"name":"/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/node_modules/.cache/rollup-plugin-typescript2/placeholder/src/model/public_types.d.ts","writeByteOrderMark":false,"text":"/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { FirebaseApp } from '@firebase/app';\r\nimport { CompleteFn, ErrorFn, FirebaseError, NextFn, Observer, Unsubscribe } from '@firebase/util';\r\nimport { FactorId as FactorIdMap, OperationType as OperationTypeMap, ActionCodeOperation as ActionCodeOperationMap } from './enum_maps';\r\nexport { CompleteFn, ErrorFn, NextFn, Unsubscribe };\r\n/**\r\n * Interface representing the `Auth` config.\r\n *\r\n * @public\r\n */\r\nexport interface Config {\r\n    /**\r\n     * The API Key used to communicate with the Firebase Auth backend.\r\n     */\r\n    apiKey: string;\r\n    /**\r\n     * The host at which the Firebase Auth backend is running.\r\n     */\r\n    apiHost: string;\r\n    /**\r\n     * The scheme used to communicate with the Firebase Auth backend.\r\n     */\r\n    apiScheme: string;\r\n    /**\r\n     * The host at which the Secure Token API is running.\r\n     */\r\n    tokenApiHost: string;\r\n    /**\r\n     * The SDK Client Version.\r\n     */\r\n    sdkClientVersion: string;\r\n    /**\r\n     * The domain at which the web widgets are hosted (provided via Firebase Config).\r\n     */\r\n    authDomain?: string;\r\n}\r\n/**\r\n * Interface representing reCAPTCHA parameters.\r\n *\r\n * See the [reCAPTCHA docs](https://developers.google.com/recaptcha/docs/display#render_param)\r\n * for the list of accepted parameters. All parameters are accepted except for `sitekey`: Firebase Auth\r\n * provisions a reCAPTCHA for each project and will configure the site key upon rendering.\r\n *\r\n * For an invisible reCAPTCHA, set the `size` key to `invisible`.\r\n *\r\n * @public\r\n */\r\nexport interface RecaptchaParameters {\r\n    [key: string]: any;\r\n}\r\n/**\r\n * Interface representing a parsed ID token.\r\n *\r\n * @privateRemarks TODO(avolkovi): consolidate with parsed_token in implementation.\r\n *\r\n * @public\r\n */\r\nexport interface ParsedToken {\r\n    /** Expiration time of the token. */\r\n    'exp'?: string;\r\n    /** UID of the user. */\r\n    'sub'?: string;\r\n    /** Time at which authentication was performed. */\r\n    'auth_time'?: string;\r\n    /** Issuance time of the token. */\r\n    'iat'?: string;\r\n    /** Firebase specific claims, containing the provider(s) used to authenticate the user. */\r\n    'firebase'?: {\r\n        'sign_in_provider'?: string;\r\n        'sign_in_second_factor'?: string;\r\n        'identities'?: Record<string, string>;\r\n    };\r\n    /** Map of any additional custom claims. */\r\n    [key: string]: unknown;\r\n}\r\n/**\r\n * Type definition for an event callback.\r\n *\r\n * @privateRemarks TODO(avolkovi): should we consolidate with Subscribe<T> since we're changing the API anyway?\r\n *\r\n * @public\r\n */\r\nexport declare type NextOrObserver<T> = NextFn<T | null> | Observer<T | null>;\r\n/**\r\n * Interface for an `Auth` error.\r\n *\r\n * @public\r\n */\r\nexport interface AuthError extends FirebaseError {\r\n    /** Details about the Firebase Auth error.  */\r\n    readonly customData: {\r\n        /** The name of the Firebase App which triggered this error.  */\r\n        readonly appName: string;\r\n        /** The email address of the user's account, used for sign-in and linking. */\r\n        readonly email?: string;\r\n        /** The phone number of the user's account, used for sign-in and linking. */\r\n        readonly phoneNumber?: string;\r\n        /**\r\n         * The tenant ID being used for sign-in and linking.\r\n         *\r\n         * @remarks\r\n         * If you use {@link signInWithRedirect} to sign in,\r\n         * you have to set the tenant ID on the {@link Auth} instance again as the tenant ID is not persisted\r\n         * after redirection.\r\n         */\r\n        readonly tenantId?: string;\r\n    };\r\n}\r\n/**\r\n * Interface representing an {@link Auth} instance's settings.\r\n *\r\n * @remarks Currently used for enabling/disabling app verification for phone Auth testing.\r\n *\r\n * @public\r\n */\r\nexport interface AuthSettings {\r\n    /**\r\n     * When set, this property disables app verification for the purpose of testing phone\r\n     * authentication. For this property to take effect, it needs to be set before rendering a\r\n     * reCAPTCHA app verifier. When this is disabled, a mock reCAPTCHA is rendered instead. This is\r\n     * useful for manual testing during development or for automated integration tests.\r\n     *\r\n     * In order to use this feature, you will need to\r\n     * {@link https://firebase.google.com/docs/auth/web/phone-auth#test-with-whitelisted-phone-numbers | whitelist your phone number}\r\n     * via the Firebase Console.\r\n     *\r\n     * The default value is false (app verification is enabled).\r\n     */\r\n    appVerificationDisabledForTesting: boolean;\r\n}\r\n/**\r\n * Interface representing Firebase Auth service.\r\n *\r\n * @remarks\r\n * See {@link https://firebase.google.com/docs/auth/ | Firebase Authentication} for a full guide\r\n * on how to use the Firebase Auth service.\r\n *\r\n * @public\r\n */\r\nexport interface Auth {\r\n    /** The {@link @firebase/app#FirebaseApp} associated with the `Auth` service instance. */\r\n    readonly app: FirebaseApp;\r\n    /** The name of the app associated with the `Auth` service instance. */\r\n    readonly name: string;\r\n    /** The {@link Config} used to initialize this instance. */\r\n    readonly config: Config;\r\n    /**\r\n     * Changes the type of persistence on the `Auth` instance.\r\n     *\r\n     * @remarks\r\n     * This will affect the currently saved Auth session and applies this type of persistence for\r\n     * future sign-in requests, including sign-in with redirect requests.\r\n     *\r\n     * This makes it easy for a user signing in to specify whether their session should be\r\n     * remembered or not. It also makes it easier to never persist the Auth state for applications\r\n     * that are shared by other users or have sensitive data.\r\n     *\r\n     * This method does not work in a Node.js environment.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * auth.setPersistence(browserSessionPersistence);\r\n     * ```\r\n     *\r\n     * @param persistence - The {@link Persistence} to use.\r\n     */\r\n    setPersistence(persistence: Persistence): Promise<void>;\r\n    /**\r\n     * The {@link Auth} instance's language code.\r\n     *\r\n     * @remarks\r\n     * This is a readable/writable property. When set to null, the default Firebase Console language\r\n     * setting is applied. The language code will propagate to email action templates (password\r\n     * reset, email verification and email change revocation), SMS templates for phone authentication,\r\n     * reCAPTCHA verifier and OAuth popup/redirect operations provided the specified providers support\r\n     * localization with the language code specified.\r\n     */\r\n    languageCode: string | null;\r\n    /**\r\n     * The {@link Auth} instance's tenant ID.\r\n     *\r\n     * @remarks\r\n     * This is a readable/writable property. When you set the tenant ID of an {@link Auth} instance, all\r\n     * future sign-in/sign-up operations will pass this tenant ID and sign in or sign up users to\r\n     * the specified tenant project. When set to null, users are signed in to the parent project.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Set the tenant ID on Auth instance.\r\n     * auth.tenantId = 'TENANT_PROJECT_ID';\r\n     *\r\n     * // All future sign-in request now include tenant ID.\r\n     * const result = await signInWithEmailAndPassword(auth, email, password);\r\n     * // result.user.tenantId should be 'TENANT_PROJECT_ID'.\r\n     * ```\r\n     *\r\n     * @defaultValue null\r\n     */\r\n    tenantId: string | null;\r\n    /**\r\n     * The {@link Auth} instance's settings.\r\n     *\r\n     * @remarks\r\n     * This is used to edit/read configuration related options such as app verification mode for\r\n     * phone authentication.\r\n     */\r\n    readonly settings: AuthSettings;\r\n    /**\r\n     * Adds an observer for changes to the user's sign-in state.\r\n     *\r\n     * @remarks\r\n     * To keep the old behavior, see {@link Auth.onIdTokenChanged}.\r\n     *\r\n     * @param nextOrObserver - callback triggered on change.\r\n     * @param error - Deprecated. This callback is never triggered. Errors\r\n     * on signing in/out can be caught in promises returned from\r\n     * sign-in/sign-out functions.\r\n     * @param completed - Deprecated. This callback is never triggered.\r\n     */\r\n    onAuthStateChanged(nextOrObserver: NextOrObserver<User | null>, error?: ErrorFn, completed?: CompleteFn): Unsubscribe;\r\n    /**\r\n     * Adds a blocking callback that runs before an auth state change\r\n     * sets a new user.\r\n     *\r\n     * @param callback - callback triggered before new user value is set.\r\n     *   If this throws, it blocks the user from being set.\r\n     * @param onAbort - callback triggered if a later `beforeAuthStateChanged()`\r\n     *   callback throws, allowing you to undo any side effects.\r\n     */\r\n    beforeAuthStateChanged(callback: (user: User | null) => void | Promise<void>, onAbort?: () => void): Unsubscribe;\r\n    /**\r\n     * Adds an observer for changes to the signed-in user's ID token.\r\n     *\r\n     * @remarks\r\n     * This includes sign-in, sign-out, and token refresh events.\r\n     *\r\n     * @param nextOrObserver - callback triggered on change.\r\n     * @param error - Deprecated. This callback is never triggered. Errors\r\n     * on signing in/out can be caught in promises returned from\r\n     * sign-in/sign-out functions.\r\n     * @param completed - Deprecated. This callback is never triggered.\r\n     */\r\n    onIdTokenChanged(nextOrObserver: NextOrObserver<User | null>, error?: ErrorFn, completed?: CompleteFn): Unsubscribe;\r\n    /**\r\n     * returns a promise that resolves immediately when the initial\r\n     * auth state is settled. When the promise resolves, the current user might be a valid user\r\n     * or `null` if the user signed out.\r\n     */\r\n    authStateReady(): Promise<void>;\r\n    /** The currently signed-in user (or null). */\r\n    readonly currentUser: User | null;\r\n    /** The current emulator configuration (or null). */\r\n    readonly emulatorConfig: EmulatorConfig | null;\r\n    /**\r\n     * Asynchronously sets the provided user as {@link Auth.currentUser} on the {@link Auth} instance.\r\n     *\r\n     * @remarks\r\n     * A new instance copy of the user provided will be made and set as currentUser.\r\n     *\r\n     * This will trigger {@link Auth.onAuthStateChanged} and {@link Auth.onIdTokenChanged} listeners\r\n     * like other sign in methods.\r\n     *\r\n     * The operation fails with an error if the user to be updated belongs to a different Firebase\r\n     * project.\r\n     *\r\n     * @param user - The new {@link User}.\r\n     */\r\n    updateCurrentUser(user: User | null): Promise<void>;\r\n    /**\r\n     * Sets the current language to the default device/browser preference.\r\n     */\r\n    useDeviceLanguage(): void;\r\n    /**\r\n     * Signs out the current user. This does not automatically revoke the user's ID token.\r\n     */\r\n    signOut(): Promise<void>;\r\n}\r\n/**\r\n * An interface covering the possible persistence mechanism types.\r\n *\r\n * @public\r\n */\r\nexport interface Persistence {\r\n    /**\r\n     * Type of Persistence.\r\n     * - 'SESSION' is used for temporary persistence such as `sessionStorage`.\r\n     * - 'LOCAL' is used for long term persistence such as `localStorage` or `IndexedDB`.\r\n     * - 'NONE' is used for in-memory, or no persistence.\r\n     */\r\n    readonly type: 'SESSION' | 'LOCAL' | 'NONE';\r\n}\r\n/**\r\n * Interface representing ID token result obtained from {@link User.getIdTokenResult}.\r\n *\r\n * @remarks\r\n * `IdTokenResult` contains the ID token JWT string and other helper properties for getting different data\r\n * associated with the token as well as all the decoded payload claims.\r\n *\r\n * Note that these claims are not to be trusted as they are parsed client side. Only server side\r\n * verification can guarantee the integrity of the token claims.\r\n *\r\n * @public\r\n */\r\nexport interface IdTokenResult {\r\n    /**\r\n     * The authentication time formatted as a UTC string.\r\n     *\r\n     * @remarks\r\n     * This is the time the user authenticated (signed in) and not the time the token was refreshed.\r\n     */\r\n    authTime: string;\r\n    /** The ID token expiration time formatted as a UTC string. */\r\n    expirationTime: string;\r\n    /** The ID token issuance time formatted as a UTC string. */\r\n    issuedAtTime: string;\r\n    /**\r\n     * The sign-in provider through which the ID token was obtained (anonymous, custom, phone,\r\n     * password, etc).\r\n     *\r\n     * @remarks\r\n     * Note, this does not map to provider IDs.\r\n     */\r\n    signInProvider: string | null;\r\n    /**\r\n     * The type of second factor associated with this session, provided the user was multi-factor\r\n     * authenticated (eg. phone, etc).\r\n     */\r\n    signInSecondFactor: string | null;\r\n    /** The Firebase Auth ID token JWT string. */\r\n    token: string;\r\n    /**\r\n     * The entire payload claims of the ID token including the standard reserved claims as well as\r\n     * the custom claims.\r\n     */\r\n    claims: ParsedToken;\r\n}\r\n/**\r\n * A response from {@link checkActionCode}.\r\n *\r\n * @public\r\n */\r\nexport interface ActionCodeInfo {\r\n    /**\r\n     * The data associated with the action code.\r\n     *\r\n     * @remarks\r\n     * For the {@link ActionCodeOperation}.PASSWORD_RESET, {@link ActionCodeOperation}.VERIFY_EMAIL, and\r\n     * {@link ActionCodeOperation}.RECOVER_EMAIL actions, this object contains an email field with the address\r\n     * the email was sent to.\r\n     *\r\n     * For the {@link ActionCodeOperation}.RECOVER_EMAIL action, which allows a user to undo an email address\r\n     * change, this object also contains a `previousEmail` field with the user account's current\r\n     * email address. After the action completes, the user's email address will revert to the value\r\n     * in the `email` field from the value in `previousEmail` field.\r\n     *\r\n     * For the {@link ActionCodeOperation}.VERIFY_AND_CHANGE_EMAIL action, which allows a user to verify the\r\n     * email before updating it, this object contains a `previousEmail` field with the user account's\r\n     * email address before updating. After the action completes, the user's email address will be\r\n     * updated to the value in the `email` field from the value in `previousEmail` field.\r\n     *\r\n     * For the {@link ActionCodeOperation}.REVERT_SECOND_FACTOR_ADDITION action, which allows a user to\r\n     * unenroll a newly added second factor, this object contains a `multiFactorInfo` field with\r\n     * the information about the second factor. For phone second factor, the `multiFactorInfo`\r\n     * is a {@link MultiFactorInfo} object, which contains the phone number.\r\n     */\r\n    data: {\r\n        email?: string | null;\r\n        multiFactorInfo?: MultiFactorInfo | null;\r\n        previousEmail?: string | null;\r\n    };\r\n    /**\r\n     * The type of operation that generated the action code.\r\n     */\r\n    operation: (typeof ActionCodeOperationMap)[keyof typeof ActionCodeOperationMap];\r\n}\r\n/**\r\n * An enumeration of the possible email action types.\r\n *\r\n * @internal\r\n */\r\nexport declare const enum ActionCodeOperation {\r\n    /** The email link sign-in action. */\r\n    EMAIL_SIGNIN = \"EMAIL_SIGNIN\",\r\n    /** The password reset action. */\r\n    PASSWORD_RESET = \"PASSWORD_RESET\",\r\n    /** The email revocation action. */\r\n    RECOVER_EMAIL = \"RECOVER_EMAIL\",\r\n    /** The revert second factor addition email action. */\r\n    REVERT_SECOND_FACTOR_ADDITION = \"REVERT_SECOND_FACTOR_ADDITION\",\r\n    /** The revert second factor addition email action. */\r\n    VERIFY_AND_CHANGE_EMAIL = \"VERIFY_AND_CHANGE_EMAIL\",\r\n    /** The email verification action. */\r\n    VERIFY_EMAIL = \"VERIFY_EMAIL\"\r\n}\r\n/**\r\n * An interface that defines the required continue/state URL with optional Android and iOS\r\n * bundle identifiers.\r\n *\r\n * @public\r\n */\r\nexport interface ActionCodeSettings {\r\n    /**\r\n     * Sets the Android package name.\r\n     *\r\n     * @remarks\r\n     * This will try to open the link in an android app if it is\r\n     * installed. If `installApp` is passed, it specifies whether to install the Android app if the\r\n     * device supports it and the app is not already installed. If this field is provided without\r\n     * a `packageName`, an error is thrown explaining that the `packageName` must be provided in\r\n     * conjunction with this field. If `minimumVersion` is specified, and an older version of the\r\n     * app is installed, the user is taken to the Play Store to upgrade the app.\r\n     */\r\n    android?: {\r\n        installApp?: boolean;\r\n        minimumVersion?: string;\r\n        packageName: string;\r\n    };\r\n    /**\r\n     * When set to true, the action code link will be be sent as a Universal Link or Android App\r\n     * Link and will be opened by the app if installed.\r\n     *\r\n     * @remarks\r\n     * In the false case, the code will be sent to the web widget first and then on continue will\r\n     * redirect to the app if installed.\r\n     *\r\n     * @defaultValue false\r\n     */\r\n    handleCodeInApp?: boolean;\r\n    /**\r\n     * Sets the iOS bundle ID.\r\n     *\r\n     * @remarks\r\n     * This will try to open the link in an iOS app if it is installed.\r\n     *\r\n     * App installation is not supported for iOS.\r\n     */\r\n    iOS?: {\r\n        bundleId: string;\r\n    };\r\n    /**\r\n     * Sets the link continue/state URL.\r\n     *\r\n     * @remarks\r\n     * This has different meanings in different contexts:\r\n     * - When the link is handled in the web action widgets, this is the deep link in the\r\n     * `continueUrl` query parameter.\r\n     * - When the link is handled in the app directly, this is the `continueUrl` query parameter in\r\n     * the deep link of the Dynamic Link.\r\n     */\r\n    url: string;\r\n    /**\r\n     * When multiple custom dynamic link domains are defined for a project, specify which one to use\r\n     * when the link is to be opened via a specified mobile app (for example, `example.page.link`).\r\n     *\r\n     *\r\n     * @defaultValue The first domain is automatically selected.\r\n     */\r\n    dynamicLinkDomain?: string;\r\n}\r\n/**\r\n * A verifier for domain verification and abuse prevention.\r\n *\r\n * @remarks\r\n * Currently, the only implementation is {@link RecaptchaVerifier}.\r\n *\r\n * @public\r\n */\r\nexport interface ApplicationVerifier {\r\n    /**\r\n     * Identifies the type of application verifier (e.g. \"recaptcha\").\r\n     */\r\n    readonly type: string;\r\n    /**\r\n     * Executes the verification process.\r\n     *\r\n     * @returns A Promise for a token that can be used to assert the validity of a request.\r\n     */\r\n    verify(): Promise<string>;\r\n}\r\n/**\r\n * Interface that represents an auth provider, used to facilitate creating {@link AuthCredential}.\r\n *\r\n * @public\r\n */\r\nexport interface AuthProvider {\r\n    /**\r\n     * Provider for which credentials can be constructed.\r\n     */\r\n    readonly providerId: string;\r\n}\r\n/**\r\n * An enum of factors that may be used for multifactor authentication.\r\n *\r\n * Internally we use an enum type for FactorId, ActionCodeOperation, but there is a copy in https://github.com/firebase/firebase-js-sdk/blob/48a2096aec53a7eaa9ffcc2625016ecb9f90d113/packages/auth/src/model/enum_maps.ts#L23 that uses maps.\r\n * const enums are better for tree-shaking, however can cause runtime errors if exposed in public APIs, example - https://github.com/microsoft/rushstack/issues/3058\r\n * So, we expose enum maps publicly, but use const enums internally to get some tree-shaking benefit.\r\n * @internal\r\n */\r\nexport declare const enum FactorId {\r\n    /** Phone as second factor */\r\n    PHONE = \"phone\",\r\n    TOTP = \"totp\"\r\n}\r\n/**\r\n * A result from a phone number sign-in, link, or reauthenticate call.\r\n *\r\n * @public\r\n */\r\nexport interface ConfirmationResult {\r\n    /**\r\n     * The phone number authentication operation's verification ID.\r\n     *\r\n     * @remarks\r\n     * This can be used along with the verification code to initialize a\r\n     * {@link PhoneAuthCredential}.\r\n     */\r\n    readonly verificationId: string;\r\n    /**\r\n     * Finishes a phone number sign-in, link, or reauthentication.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * const confirmationResult = await signInWithPhoneNumber(auth, phoneNumber, applicationVerifier);\r\n     * // Obtain verificationCode from the user.\r\n     * const userCredential = await confirmationResult.confirm(verificationCode);\r\n     * ```\r\n     *\r\n     * @param verificationCode - The code that was sent to the user's mobile device.\r\n     */\r\n    confirm(verificationCode: string): Promise<UserCredential>;\r\n}\r\n/**\r\n * The base class for asserting ownership of a second factor.\r\n *\r\n * @remarks\r\n * This is used to facilitate enrollment of a second factor on an existing user or sign-in of a\r\n * user who already verified the first factor.\r\n *\r\n * @public\r\n */\r\nexport interface MultiFactorAssertion {\r\n    /** The identifier of the second factor. */\r\n    readonly factorId: (typeof FactorIdMap)[keyof typeof FactorIdMap];\r\n}\r\n/**\r\n * The error thrown when the user needs to provide a second factor to sign in successfully.\r\n *\r\n * @remarks\r\n * The error code for this error is `auth/multi-factor-auth-required`.\r\n *\r\n * @example\r\n * ```javascript\r\n * let resolver;\r\n * let multiFactorHints;\r\n *\r\n * signInWithEmailAndPassword(auth, email, password)\r\n *     .then((result) => {\r\n *       // User signed in. No 2nd factor challenge is needed.\r\n *     })\r\n *     .catch((error) => {\r\n *       if (error.code == 'auth/multi-factor-auth-required') {\r\n *         resolver = getMultiFactorResolver(auth, error);\r\n *         multiFactorHints = resolver.hints;\r\n *       } else {\r\n *         // Handle other errors.\r\n *       }\r\n *     });\r\n *\r\n * // Obtain a multiFactorAssertion by verifying the second factor.\r\n *\r\n * const userCredential = await resolver.resolveSignIn(multiFactorAssertion);\r\n * ```\r\n *\r\n * @public\r\n */\r\nexport interface MultiFactorError extends AuthError {\r\n    /** Details about the MultiFactorError. */\r\n    readonly customData: AuthError['customData'] & {\r\n        /**\r\n         * The type of operation (sign-in, linking, or re-authentication) that raised the error.\r\n         */\r\n        readonly operationType: (typeof OperationTypeMap)[keyof typeof OperationTypeMap];\r\n    };\r\n}\r\n/**\r\n * A structure containing the information of a second factor entity.\r\n *\r\n * @public\r\n */\r\nexport interface MultiFactorInfo {\r\n    /** The multi-factor enrollment ID. */\r\n    readonly uid: string;\r\n    /** The user friendly name of the current second factor. */\r\n    readonly displayName?: string | null;\r\n    /** The enrollment date of the second factor formatted as a UTC string. */\r\n    readonly enrollmentTime: string;\r\n    /** The identifier of the second factor. */\r\n    readonly factorId: (typeof FactorIdMap)[keyof typeof FactorIdMap];\r\n}\r\n/**\r\n * The subclass of the {@link MultiFactorInfo} interface for phone number\r\n * second factors. The `factorId` of this second factor is {@link FactorId}.PHONE.\r\n * @public\r\n */\r\nexport interface PhoneMultiFactorInfo extends MultiFactorInfo {\r\n    /** The phone number associated with the current second factor. */\r\n    readonly phoneNumber: string;\r\n}\r\n/**\r\n * The subclass of the {@link MultiFactorInfo} interface for TOTP\r\n * second factors. The `factorId` of this second factor is {@link FactorId}.TOTP.\r\n * @public\r\n */\r\nexport interface TotpMultiFactorInfo extends MultiFactorInfo {\r\n}\r\n/**\r\n * The class used to facilitate recovery from {@link MultiFactorError} when a user needs to\r\n * provide a second factor to sign in.\r\n *\r\n * @example\r\n * ```javascript\r\n * let resolver;\r\n * let multiFactorHints;\r\n *\r\n * signInWithEmailAndPassword(auth, email, password)\r\n *     .then((result) => {\r\n *       // User signed in. No 2nd factor challenge is needed.\r\n *     })\r\n *     .catch((error) => {\r\n *       if (error.code == 'auth/multi-factor-auth-required') {\r\n *         resolver = getMultiFactorResolver(auth, error);\r\n *         // Show UI to let user select second factor.\r\n *         multiFactorHints = resolver.hints;\r\n *       } else {\r\n *         // Handle other errors.\r\n *       }\r\n *     });\r\n *\r\n * // The enrolled second factors that can be used to complete\r\n * // sign-in are returned in the `MultiFactorResolver.hints` list.\r\n * // UI needs to be presented to allow the user to select a second factor\r\n * // from that list.\r\n *\r\n * const selectedHint = // ; selected from multiFactorHints\r\n * const phoneAuthProvider = new PhoneAuthProvider(auth);\r\n * const phoneInfoOptions = {\r\n *   multiFactorHint: selectedHint,\r\n *   session: resolver.session\r\n * };\r\n * const verificationId = phoneAuthProvider.verifyPhoneNumber(phoneInfoOptions, appVerifier);\r\n * // Store `verificationId` and show UI to let user enter verification code.\r\n *\r\n * // UI to enter verification code and continue.\r\n * // Continue button click handler\r\n * const phoneAuthCredential = PhoneAuthProvider.credential(verificationId, verificationCode);\r\n * const multiFactorAssertion = PhoneMultiFactorGenerator.assertion(phoneAuthCredential);\r\n * const userCredential = await resolver.resolveSignIn(multiFactorAssertion);\r\n * ```\r\n *\r\n * @public\r\n */\r\nexport interface MultiFactorResolver {\r\n    /**\r\n     * The list of hints for the second factors needed to complete the sign-in for the current\r\n     * session.\r\n     */\r\n    readonly hints: MultiFactorInfo[];\r\n    /**\r\n     * The session identifier for the current sign-in flow, which can be used to complete the second\r\n     * factor sign-in.\r\n     */\r\n    readonly session: MultiFactorSession;\r\n    /**\r\n     * A helper function to help users complete sign in with a second factor using an\r\n     * {@link MultiFactorAssertion} confirming the user successfully completed the second factor\r\n     * challenge.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * const phoneAuthCredential = PhoneAuthProvider.credential(verificationId, verificationCode);\r\n     * const multiFactorAssertion = PhoneMultiFactorGenerator.assertion(phoneAuthCredential);\r\n     * const userCredential = await resolver.resolveSignIn(multiFactorAssertion);\r\n     * ```\r\n     *\r\n     * @param assertion - The multi-factor assertion to resolve sign-in with.\r\n     * @returns The promise that resolves with the user credential object.\r\n     */\r\n    resolveSignIn(assertion: MultiFactorAssertion): Promise<UserCredential>;\r\n}\r\n/**\r\n * An interface defining the multi-factor session object used for enrolling a second factor on a\r\n * user or helping sign in an enrolled user with a second factor.\r\n *\r\n * @public\r\n */\r\nexport interface MultiFactorSession {\r\n}\r\n/**\r\n * An interface that defines the multi-factor related properties and operations pertaining\r\n * to a {@link User}.\r\n *\r\n * @public\r\n */\r\nexport interface MultiFactorUser {\r\n    /** Returns a list of the user's enrolled second factors. */\r\n    readonly enrolledFactors: MultiFactorInfo[];\r\n    /**\r\n     * Returns the session identifier for a second factor enrollment operation. This is used to\r\n     * identify the user trying to enroll a second factor.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * const multiFactorUser = multiFactor(auth.currentUser);\r\n     * const multiFactorSession = await multiFactorUser.getSession();\r\n     *\r\n     * // Send verification code.\r\n     * const phoneAuthProvider = new PhoneAuthProvider(auth);\r\n     * const phoneInfoOptions = {\r\n     *   phoneNumber: phoneNumber,\r\n     *   session: multiFactorSession\r\n     * };\r\n     * const verificationId = await phoneAuthProvider.verifyPhoneNumber(phoneInfoOptions, appVerifier);\r\n     *\r\n     * // Obtain verification code from user.\r\n     * const phoneAuthCredential = PhoneAuthProvider.credential(verificationId, verificationCode);\r\n     * const multiFactorAssertion = PhoneMultiFactorGenerator.assertion(phoneAuthCredential);\r\n     * await multiFactorUser.enroll(multiFactorAssertion);\r\n     * ```\r\n     *\r\n     * @returns The promise that resolves with the {@link MultiFactorSession}.\r\n     */\r\n    getSession(): Promise<MultiFactorSession>;\r\n    /**\r\n     *\r\n     * Enrolls a second factor as identified by the {@link MultiFactorAssertion} for the\r\n     * user.\r\n     *\r\n     * @remarks\r\n     * On resolution, the user tokens are updated to reflect the change in the JWT payload.\r\n     * Accepts an additional display name parameter used to identify the second factor to the end\r\n     * user. Recent re-authentication is required for this operation to succeed. On successful\r\n     * enrollment, existing Firebase sessions (refresh tokens) are revoked. When a new factor is\r\n     * enrolled, an email notification is sent to the user’s email.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * const multiFactorUser = multiFactor(auth.currentUser);\r\n     * const multiFactorSession = await multiFactorUser.getSession();\r\n     *\r\n     * // Send verification code.\r\n     * const phoneAuthProvider = new PhoneAuthProvider(auth);\r\n     * const phoneInfoOptions = {\r\n     *   phoneNumber: phoneNumber,\r\n     *   session: multiFactorSession\r\n     * };\r\n     * const verificationId = await phoneAuthProvider.verifyPhoneNumber(phoneInfoOptions, appVerifier);\r\n     *\r\n     * // Obtain verification code from user.\r\n     * const phoneAuthCredential = PhoneAuthProvider.credential(verificationId, verificationCode);\r\n     * const multiFactorAssertion = PhoneMultiFactorGenerator.assertion(phoneAuthCredential);\r\n     * await multiFactorUser.enroll(multiFactorAssertion);\r\n     * // Second factor enrolled.\r\n     * ```\r\n     *\r\n     * @param assertion - The multi-factor assertion to enroll with.\r\n     * @param displayName - The display name of the second factor.\r\n     */\r\n    enroll(assertion: MultiFactorAssertion, displayName?: string | null): Promise<void>;\r\n    /**\r\n     * Unenrolls the specified second factor.\r\n     *\r\n     * @remarks\r\n     * To specify the factor to remove, pass a {@link MultiFactorInfo} object (retrieved from\r\n     * {@link MultiFactorUser.enrolledFactors}) or the\r\n     * factor's UID string. Sessions are not revoked when the account is unenrolled. An email\r\n     * notification is likely to be sent to the user notifying them of the change. Recent\r\n     * re-authentication is required for this operation to succeed. When an existing factor is\r\n     * unenrolled, an email notification is sent to the user’s email.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * const multiFactorUser = multiFactor(auth.currentUser);\r\n     * // Present user the option to choose which factor to unenroll.\r\n     * await multiFactorUser.unenroll(multiFactorUser.enrolledFactors[i])\r\n     * ```\r\n     *\r\n     * @param option - The multi-factor option to unenroll.\r\n     * @returns - A `Promise` which resolves when the unenroll operation is complete.\r\n     */\r\n    unenroll(option: MultiFactorInfo | string): Promise<void>;\r\n}\r\n/**\r\n * The class for asserting ownership of a phone second factor. Provided by\r\n * {@link PhoneMultiFactorGenerator.assertion}.\r\n *\r\n * @public\r\n */\r\nexport interface PhoneMultiFactorAssertion extends MultiFactorAssertion {\r\n}\r\n/**\r\n * The information required to verify the ownership of a phone number.\r\n *\r\n * @remarks\r\n * The information that's required depends on whether you are doing single-factor sign-in,\r\n * multi-factor enrollment or multi-factor sign-in.\r\n *\r\n * @public\r\n */\r\nexport declare type PhoneInfoOptions = PhoneSingleFactorInfoOptions | PhoneMultiFactorEnrollInfoOptions | PhoneMultiFactorSignInInfoOptions;\r\n/**\r\n * Options used for single-factor sign-in.\r\n *\r\n * @public\r\n */\r\nexport interface PhoneSingleFactorInfoOptions {\r\n    /** Phone number to send a verification code to. */\r\n    phoneNumber: string;\r\n}\r\n/**\r\n * Options used for enrolling a second factor.\r\n *\r\n * @public\r\n */\r\nexport interface PhoneMultiFactorEnrollInfoOptions {\r\n    /** Phone number to send a verification code to. */\r\n    phoneNumber: string;\r\n    /** The {@link MultiFactorSession} obtained via {@link MultiFactorUser.getSession}. */\r\n    session: MultiFactorSession;\r\n}\r\n/**\r\n * Options used for signing in with a second factor.\r\n *\r\n * @public\r\n */\r\nexport interface PhoneMultiFactorSignInInfoOptions {\r\n    /**\r\n     * The {@link MultiFactorInfo} obtained via {@link MultiFactorResolver.hints}.\r\n     *\r\n     * One of `multiFactorHint` or `multiFactorUid` is required.\r\n     */\r\n    multiFactorHint?: MultiFactorInfo;\r\n    /**\r\n     * The uid of the second factor.\r\n     *\r\n     * One of `multiFactorHint` or `multiFactorUid` is required.\r\n     */\r\n    multiFactorUid?: string;\r\n    /** The {@link MultiFactorSession} obtained via {@link MultiFactorResolver.session}. */\r\n    session: MultiFactorSession;\r\n}\r\n/**\r\n * Interface for a supplied `AsyncStorage`.\r\n *\r\n * @public\r\n */\r\nexport interface ReactNativeAsyncStorage {\r\n    /**\r\n     * Persist an item in storage.\r\n     *\r\n     * @param key - storage key.\r\n     * @param value - storage value.\r\n     */\r\n    setItem(key: string, value: string): Promise<void>;\r\n    /**\r\n     * Retrieve an item from storage.\r\n     *\r\n     * @param key - storage key.\r\n     */\r\n    getItem(key: string): Promise<string | null>;\r\n    /**\r\n     * Remove an item from storage.\r\n     *\r\n     * @param key - storage key.\r\n     */\r\n    removeItem(key: string): Promise<void>;\r\n}\r\n/**\r\n * A user account.\r\n *\r\n * @public\r\n */\r\nexport interface User extends UserInfo {\r\n    /**\r\n     * Whether the email has been verified with {@link sendEmailVerification} and\r\n     * {@link applyActionCode}.\r\n     */\r\n    readonly emailVerified: boolean;\r\n    /**\r\n     * Whether the user is authenticated using the {@link ProviderId}.ANONYMOUS provider.\r\n     */\r\n    readonly isAnonymous: boolean;\r\n    /**\r\n     * Additional metadata around user creation and sign-in times.\r\n     */\r\n    readonly metadata: UserMetadata;\r\n    /**\r\n     * Additional per provider such as displayName and profile information.\r\n     */\r\n    readonly providerData: UserInfo[];\r\n    /**\r\n     * Refresh token used to reauthenticate the user. Avoid using this directly and prefer\r\n     * {@link User.getIdToken} to refresh the ID token instead.\r\n     */\r\n    readonly refreshToken: string;\r\n    /**\r\n     * The user's tenant ID.\r\n     *\r\n     * @remarks\r\n     * This is a read-only property, which indicates the tenant ID\r\n     * used to sign in the user. This is null if the user is signed in from the parent\r\n     * project.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Set the tenant ID on Auth instance.\r\n     * auth.tenantId = 'TENANT_PROJECT_ID';\r\n     *\r\n     * // All future sign-in request now include tenant ID.\r\n     * const result = await signInWithEmailAndPassword(auth, email, password);\r\n     * // result.user.tenantId should be 'TENANT_PROJECT_ID'.\r\n     * ```\r\n     */\r\n    readonly tenantId: string | null;\r\n    /**\r\n     * Deletes and signs out the user.\r\n     *\r\n     * @remarks\r\n     * Important: this is a security-sensitive operation that requires the user to have recently\r\n     * signed in. If this requirement isn't met, ask the user to authenticate again and then call\r\n     * one of the reauthentication methods like {@link reauthenticateWithCredential}.\r\n     */\r\n    delete(): Promise<void>;\r\n    /**\r\n     * Returns a JSON Web Token (JWT) used to identify the user to a Firebase service.\r\n     *\r\n     * @remarks\r\n     * Returns the current token if it has not expired or if it will not expire in the next five\r\n     * minutes. Otherwise, this will refresh the token and return a new one.\r\n     *\r\n     * @param forceRefresh - Force refresh regardless of token expiration.\r\n     */\r\n    getIdToken(forceRefresh?: boolean): Promise<string>;\r\n    /**\r\n     * Returns a deserialized JSON Web Token (JWT) used to identify the user to a Firebase service.\r\n     *\r\n     * @remarks\r\n     * Returns the current token if it has not expired or if it will not expire in the next five\r\n     * minutes. Otherwise, this will refresh the token and return a new one.\r\n     *\r\n     * @param forceRefresh - Force refresh regardless of token expiration.\r\n     */\r\n    getIdTokenResult(forceRefresh?: boolean): Promise<IdTokenResult>;\r\n    /**\r\n     * Refreshes the user, if signed in.\r\n     */\r\n    reload(): Promise<void>;\r\n    /**\r\n     * Returns a JSON-serializable representation of this object.\r\n     *\r\n     * @returns A JSON-serializable representation of this object.\r\n     */\r\n    toJSON(): object;\r\n}\r\n/**\r\n * A structure containing a {@link User}, the {@link OperationType}, and the provider ID.\r\n *\r\n * @remarks\r\n * `operationType` could be {@link OperationType}.SIGN_IN for a sign-in operation,\r\n * {@link OperationType}.LINK for a linking operation and {@link OperationType}.REAUTHENTICATE for\r\n * a reauthentication operation.\r\n *\r\n * @public\r\n */\r\nexport interface UserCredential {\r\n    /**\r\n     * The user authenticated by this credential.\r\n     */\r\n    user: User;\r\n    /**\r\n     * The provider which was used to authenticate the user.\r\n     */\r\n    providerId: string | null;\r\n    /**\r\n     * The type of operation which was used to authenticate the user (such as sign-in or link).\r\n     */\r\n    operationType: (typeof OperationTypeMap)[keyof typeof OperationTypeMap];\r\n}\r\n/**\r\n * User profile information, visible only to the Firebase project's apps.\r\n *\r\n * @public\r\n */\r\nexport interface UserInfo {\r\n    /**\r\n     * The display name of the user.\r\n     */\r\n    readonly displayName: string | null;\r\n    /**\r\n     * The email of the user.\r\n     */\r\n    readonly email: string | null;\r\n    /**\r\n     * The phone number normalized based on the E.164 standard (e.g. +16505550101) for the\r\n     * user.\r\n     *\r\n     * @remarks\r\n     * This is null if the user has no phone credential linked to the account.\r\n     */\r\n    readonly phoneNumber: string | null;\r\n    /**\r\n     * The profile photo URL of the user.\r\n     */\r\n    readonly photoURL: string | null;\r\n    /**\r\n     * The provider used to authenticate the user.\r\n     */\r\n    readonly providerId: string;\r\n    /**\r\n     * The user's unique ID, scoped to the project.\r\n     */\r\n    readonly uid: string;\r\n}\r\n/**\r\n * Interface representing a user's metadata.\r\n *\r\n * @public\r\n */\r\nexport interface UserMetadata {\r\n    /** Time the user was created. */\r\n    readonly creationTime?: string;\r\n    /** Time the user last signed in. */\r\n    readonly lastSignInTime?: string;\r\n}\r\n/**\r\n * A structure containing additional user information from a federated identity provider.\r\n *\r\n * @public\r\n */\r\nexport interface AdditionalUserInfo {\r\n    /**\r\n     * Whether the user is new (created via sign-up) or existing (authenticated using sign-in).\r\n     */\r\n    readonly isNewUser: boolean;\r\n    /**\r\n     * Map containing IDP-specific user data.\r\n     */\r\n    readonly profile: Record<string, unknown> | null;\r\n    /**\r\n     * Identifier for the provider used to authenticate this user.\r\n     */\r\n    readonly providerId: string | null;\r\n    /**\r\n     * The username if the provider is GitHub or Twitter.\r\n     */\r\n    readonly username?: string | null;\r\n}\r\n/**\r\n * User profile used in {@link AdditionalUserInfo}.\r\n *\r\n * @public\r\n */\r\nexport declare type UserProfile = Record<string, unknown>;\r\n/**\r\n * A resolver used for handling DOM specific operations like {@link signInWithPopup}\r\n * or {@link signInWithRedirect}.\r\n *\r\n * @public\r\n */\r\nexport interface PopupRedirectResolver {\r\n}\r\ndeclare module '@firebase/component' {\r\n    interface NameServiceMapping {\r\n        'auth': Auth;\r\n    }\r\n}\r\n/**\r\n * Configuration of Firebase Authentication Emulator.\r\n * @public\r\n */\r\nexport interface EmulatorConfig {\r\n    /**\r\n     * The protocol used to communicate with the emulator (\"http\"/\"https\").\r\n     */\r\n    readonly protocol: string;\r\n    /**\r\n     * The hostname of the emulator, which may be a domain (\"localhost\"), IPv4 address (\"127.0.0.1\")\r\n     * or quoted IPv6 address (\"[::1]\").\r\n     */\r\n    readonly host: string;\r\n    /**\r\n     * The port of the emulator, or null if port isn't specified (i.e. protocol default).\r\n     */\r\n    readonly port: number | null;\r\n    /**\r\n     * The emulator-specific options.\r\n     */\r\n    readonly options: {\r\n        /**\r\n         * Whether the warning banner attached to the DOM was disabled.\r\n         */\r\n        readonly disableWarnings: boolean;\r\n    };\r\n}\r\n/**\r\n * A mapping of error codes to error messages.\r\n *\r\n * @remarks\r\n *\r\n * While error messages are useful for debugging (providing verbose textual\r\n * context around what went wrong), these strings take up a lot of space in the\r\n * compiled code. When deploying code in production, using {@link prodErrorMap}\r\n * will save you roughly 10k compressed/gzipped over {@link debugErrorMap}. You\r\n * can select the error map during initialization:\r\n *\r\n * ```javascript\r\n * initializeAuth(app, {errorMap: debugErrorMap})\r\n * ```\r\n *\r\n * When initializing Auth, {@link prodErrorMap} is default.\r\n *\r\n * @public\r\n */\r\nexport interface AuthErrorMap {\r\n}\r\n/**\r\n * The dependencies that can be used to initialize an {@link Auth} instance.\r\n *\r\n * @remarks\r\n *\r\n * The modular SDK enables tree shaking by allowing explicit declarations of\r\n * dependencies. For example, a web app does not need to include code that\r\n * enables Cordova redirect sign in. That functionality is therefore split into\r\n * {@link browserPopupRedirectResolver} and\r\n * {@link cordovaPopupRedirectResolver}. The dependencies object is how Auth is\r\n * configured to reduce bundle sizes.\r\n *\r\n * There are two ways to initialize an {@link Auth} instance: {@link getAuth} and\r\n * {@link initializeAuth}. `getAuth` initializes everything using\r\n * platform-specific configurations, while `initializeAuth` takes a\r\n * `Dependencies` object directly, giving you more control over what is used.\r\n *\r\n * @public\r\n */\r\nexport interface Dependencies {\r\n    /**\r\n     * Which {@link Persistence} to use. If this is an array, the first\r\n     * `Persistence` that the device supports is used. The SDK searches for an\r\n     * existing account in order and, if one is found in a secondary\r\n     * `Persistence`, the account is moved to the primary `Persistence`.\r\n     *\r\n     * If no persistence is provided, the SDK falls back on\r\n     * {@link inMemoryPersistence}.\r\n     */\r\n    persistence?: Persistence | Persistence[];\r\n    /**\r\n     * The {@link PopupRedirectResolver} to use. This value depends on the\r\n     * platform. Options are {@link browserPopupRedirectResolver} and\r\n     * {@link cordovaPopupRedirectResolver}. This field is optional if neither\r\n     * {@link signInWithPopup} or {@link signInWithRedirect} are being used.\r\n     */\r\n    popupRedirectResolver?: PopupRedirectResolver;\r\n    /**\r\n     * Which {@link AuthErrorMap} to use.\r\n     */\r\n    errorMap?: AuthErrorMap;\r\n}\r\n/**\r\n * The class for asserting ownership of a TOTP second factor. Provided by\r\n * {@link TotpMultiFactorGenerator.assertionForEnrollment} and\r\n * {@link TotpMultiFactorGenerator.assertionForSignIn}.\r\n *\r\n * @public\r\n */\r\nexport interface TotpMultiFactorAssertion extends MultiFactorAssertion {\r\n}\r\n/**\r\n * A structure specifying password policy requirements.\r\n *\r\n * @public\r\n */\r\nexport interface PasswordPolicy {\r\n    /**\r\n     * Requirements enforced by this password policy.\r\n     */\r\n    readonly customStrengthOptions: {\r\n        /**\r\n         * Minimum password length, or undefined if not configured.\r\n         */\r\n        readonly minPasswordLength?: number;\r\n        /**\r\n         * Maximum password length, or undefined if not configured.\r\n         */\r\n        readonly maxPasswordLength?: number;\r\n        /**\r\n         * Whether the password should contain a lowercase letter, or undefined if not configured.\r\n         */\r\n        readonly containsLowercaseLetter?: boolean;\r\n        /**\r\n         * Whether the password should contain an uppercase letter, or undefined if not configured.\r\n         */\r\n        readonly containsUppercaseLetter?: boolean;\r\n        /**\r\n         * Whether the password should contain a numeric character, or undefined if not configured.\r\n         */\r\n        readonly containsNumericCharacter?: boolean;\r\n        /**\r\n         * Whether the password should contain a non-alphanumeric character, or undefined if not configured.\r\n         */\r\n        readonly containsNonAlphanumericCharacter?: boolean;\r\n    };\r\n    /**\r\n     * List of characters that are considered non-alphanumeric during validation.\r\n     */\r\n    readonly allowedNonAlphanumericCharacters: string;\r\n    /**\r\n     * The enforcement state of the policy. Can be 'OFF' or 'ENFORCE'.\r\n     */\r\n    readonly enforcementState: string;\r\n    /**\r\n     * Whether existing passwords must meet the policy.\r\n     */\r\n    readonly forceUpgradeOnSignin: boolean;\r\n}\r\n/**\r\n * A structure indicating which password policy requirements were met or violated and what the\r\n * requirements are.\r\n *\r\n * @public\r\n */\r\nexport interface PasswordValidationStatus {\r\n    /**\r\n     * Whether the password meets all requirements.\r\n     */\r\n    readonly isValid: boolean;\r\n    /**\r\n     * Whether the password meets the minimum password length, or undefined if not required.\r\n     */\r\n    readonly meetsMinPasswordLength?: boolean;\r\n    /**\r\n     * Whether the password meets the maximum password length, or undefined if not required.\r\n     */\r\n    readonly meetsMaxPasswordLength?: boolean;\r\n    /**\r\n     * Whether the password contains a lowercase letter, or undefined if not required.\r\n     */\r\n    readonly containsLowercaseLetter?: boolean;\r\n    /**\r\n     * Whether the password contains an uppercase letter, or undefined if not required.\r\n     */\r\n    readonly containsUppercaseLetter?: boolean;\r\n    /**\r\n     * Whether the password contains a numeric character, or undefined if not required.\r\n     */\r\n    readonly containsNumericCharacter?: boolean;\r\n    /**\r\n     * Whether the password contains a non-alphanumeric character, or undefined if not required.\r\n     */\r\n    readonly containsNonAlphanumericCharacter?: boolean;\r\n    /**\r\n     * The policy used to validate the password.\r\n     */\r\n    readonly passwordPolicy: PasswordPolicy;\r\n}\r\n"}}
