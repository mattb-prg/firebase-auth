{"code":"/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { __awaiter, __extends, __generator } from \"tslib\";\r\nimport { _persistenceKeyName } from '../persistence/persistence_user_manager';\r\nimport { _getInstance } from '../util/instantiator';\r\nimport { AbstractPopupRedirectOperation } from './abstract_popup_redirect_operation';\r\nvar PENDING_REDIRECT_KEY = 'pendingRedirect';\r\n// We only get one redirect outcome for any one auth, so just store it\r\n// in here.\r\nvar redirectOutcomeMap = new Map();\r\nvar RedirectAction = /** @class */ (function (_super) {\r\n    __extends(RedirectAction, _super);\r\n    function RedirectAction(auth, resolver, bypassAuthState) {\r\n        if (bypassAuthState === void 0) { bypassAuthState = false; }\r\n        var _this = _super.call(this, auth, [\r\n            \"signInViaRedirect\" /* AuthEventType.SIGN_IN_VIA_REDIRECT */,\r\n            \"linkViaRedirect\" /* AuthEventType.LINK_VIA_REDIRECT */,\r\n            \"reauthViaRedirect\" /* AuthEventType.REAUTH_VIA_REDIRECT */,\r\n            \"unknown\" /* AuthEventType.UNKNOWN */\r\n        ], resolver, undefined, bypassAuthState) || this;\r\n        _this.eventId = null;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Override the execute function; if we already have a redirect result, then\r\n     * just return it.\r\n     */\r\n    RedirectAction.prototype.execute = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var readyOutcome, hasPendingRedirect, result_1, _a, e_1;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        readyOutcome = redirectOutcomeMap.get(this.auth._key());\r\n                        if (!!readyOutcome) return [3 /*break*/, 8];\r\n                        _b.label = 1;\r\n                    case 1:\r\n                        _b.trys.push([1, 6, , 7]);\r\n                        return [4 /*yield*/, _getAndClearPendingRedirectStatus(this.resolver, this.auth)];\r\n                    case 2:\r\n                        hasPendingRedirect = _b.sent();\r\n                        if (!hasPendingRedirect) return [3 /*break*/, 4];\r\n                        return [4 /*yield*/, _super.prototype.execute.call(this)];\r\n                    case 3:\r\n                        _a = _b.sent();\r\n                        return [3 /*break*/, 5];\r\n                    case 4:\r\n                        _a = null;\r\n                        _b.label = 5;\r\n                    case 5:\r\n                        result_1 = _a;\r\n                        readyOutcome = function () { return Promise.resolve(result_1); };\r\n                        return [3 /*break*/, 7];\r\n                    case 6:\r\n                        e_1 = _b.sent();\r\n                        readyOutcome = function () { return Promise.reject(e_1); };\r\n                        return [3 /*break*/, 7];\r\n                    case 7:\r\n                        redirectOutcomeMap.set(this.auth._key(), readyOutcome);\r\n                        _b.label = 8;\r\n                    case 8:\r\n                        // If we're not bypassing auth state, the ready outcome should be set to\r\n                        // null.\r\n                        if (!this.bypassAuthState) {\r\n                            redirectOutcomeMap.set(this.auth._key(), function () { return Promise.resolve(null); });\r\n                        }\r\n                        return [2 /*return*/, readyOutcome()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    RedirectAction.prototype.onAuthEvent = function (event) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var user;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (event.type === \"signInViaRedirect\" /* AuthEventType.SIGN_IN_VIA_REDIRECT */) {\r\n                            return [2 /*return*/, _super.prototype.onAuthEvent.call(this, event)];\r\n                        }\r\n                        else if (event.type === \"unknown\" /* AuthEventType.UNKNOWN */) {\r\n                            // This is a sentinel value indicating there's no pending redirect\r\n                            this.resolve(null);\r\n                            return [2 /*return*/];\r\n                        }\r\n                        if (!event.eventId) return [3 /*break*/, 2];\r\n                        return [4 /*yield*/, this.auth._redirectUserForId(event.eventId)];\r\n                    case 1:\r\n                        user = _a.sent();\r\n                        if (user) {\r\n                            this.user = user;\r\n                            return [2 /*return*/, _super.prototype.onAuthEvent.call(this, event)];\r\n                        }\r\n                        else {\r\n                            this.resolve(null);\r\n                        }\r\n                        _a.label = 2;\r\n                    case 2: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    RedirectAction.prototype.onExecution = function () {\r\n        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {\r\n            return [2 /*return*/];\r\n        }); });\r\n    };\r\n    RedirectAction.prototype.cleanUp = function () { };\r\n    return RedirectAction;\r\n}(AbstractPopupRedirectOperation));\r\nexport { RedirectAction };\r\nexport function _getAndClearPendingRedirectStatus(resolver, auth) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var key, persistence, hasPendingRedirect;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    key = pendingRedirectKey(auth);\r\n                    persistence = resolverPersistence(resolver);\r\n                    return [4 /*yield*/, persistence._isAvailable()];\r\n                case 1:\r\n                    if (!(_a.sent())) {\r\n                        return [2 /*return*/, false];\r\n                    }\r\n                    return [4 /*yield*/, persistence._get(key)];\r\n                case 2:\r\n                    hasPendingRedirect = (_a.sent()) === 'true';\r\n                    return [4 /*yield*/, persistence._remove(key)];\r\n                case 3:\r\n                    _a.sent();\r\n                    return [2 /*return*/, hasPendingRedirect];\r\n            }\r\n        });\r\n    });\r\n}\r\nexport function _setPendingRedirectStatus(resolver, auth) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            return [2 /*return*/, resolverPersistence(resolver)._set(pendingRedirectKey(auth), 'true')];\r\n        });\r\n    });\r\n}\r\nexport function _clearRedirectOutcomes() {\r\n    redirectOutcomeMap.clear();\r\n}\r\nexport function _overrideRedirectResult(auth, result) {\r\n    redirectOutcomeMap.set(auth._key(), result);\r\n}\r\nfunction resolverPersistence(resolver) {\r\n    return _getInstance(resolver._redirectPersistence);\r\n}\r\nfunction pendingRedirectKey(auth) {\r\n    return _persistenceKeyName(PENDING_REDIRECT_KEY, auth.config.apiKey, auth.name);\r\n}\r\n//# sourceMappingURL=redirect.js.map","references":["/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/model/auth.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/model/popup_redirect.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/model/user.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/core/persistence/index.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/core/persistence/persistence_user_manager.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/core/util/instantiator.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/core/strategies/abstract_popup_redirect_operation.ts"],"map":"{\"version\":3,\"file\":\"redirect.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../../src/core/strategies/redirect.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/node_modules/.cache/rollup-plugin-typescript2/placeholder/src/core/strategies/redirect.d.ts","writeByteOrderMark":false,"text":"/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { AuthInternal } from '../../model/auth';\r\nimport { AuthEvent, PopupRedirectResolverInternal } from '../../model/popup_redirect';\r\nimport { UserCredentialInternal } from '../../model/user';\r\nimport { AbstractPopupRedirectOperation } from './abstract_popup_redirect_operation';\r\nexport declare class RedirectAction extends AbstractPopupRedirectOperation {\r\n    eventId: null;\r\n    constructor(auth: AuthInternal, resolver: PopupRedirectResolverInternal, bypassAuthState?: boolean);\r\n    /**\r\n     * Override the execute function; if we already have a redirect result, then\r\n     * just return it.\r\n     */\r\n    execute(): Promise<UserCredentialInternal | null>;\r\n    onAuthEvent(event: AuthEvent): Promise<void>;\r\n    onExecution(): Promise<void>;\r\n    cleanUp(): void;\r\n}\r\nexport declare function _getAndClearPendingRedirectStatus(resolver: PopupRedirectResolverInternal, auth: AuthInternal): Promise<boolean>;\r\nexport declare function _setPendingRedirectStatus(resolver: PopupRedirectResolverInternal, auth: AuthInternal): Promise<void>;\r\nexport declare function _clearRedirectOutcomes(): void;\r\nexport declare function _overrideRedirectResult(auth: AuthInternal, result: () => Promise<UserCredentialInternal | null>): void;\r\n"}}
