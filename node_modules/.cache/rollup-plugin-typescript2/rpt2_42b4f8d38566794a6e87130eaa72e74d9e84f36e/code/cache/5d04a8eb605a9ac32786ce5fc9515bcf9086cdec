{"code":"/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { __assign, __spreadArray } from \"tslib\";\r\nimport { ErrorFactory } from '@firebase/util';\r\nimport { _DEFAULT_AUTH_ERROR_FACTORY, prodErrorMap } from '../errors';\r\nimport { _logError } from './log';\r\nexport function _fail(authOrCode) {\r\n    var rest = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        rest[_i - 1] = arguments[_i];\r\n    }\r\n    throw createErrorInternal.apply(void 0, __spreadArray([authOrCode], rest, false));\r\n}\r\nexport function _createError(authOrCode) {\r\n    var rest = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        rest[_i - 1] = arguments[_i];\r\n    }\r\n    return createErrorInternal.apply(void 0, __spreadArray([authOrCode], rest, false));\r\n}\r\nexport function _errorWithCustomMessage(auth, code, message) {\r\n    var _a;\r\n    var errorMap = __assign(__assign({}, prodErrorMap()), (_a = {}, _a[code] = message, _a));\r\n    var factory = new ErrorFactory('auth', 'Firebase', errorMap);\r\n    return factory.create(code, {\r\n        appName: auth.name\r\n    });\r\n}\r\nexport function _assertInstanceOf(auth, object, instance) {\r\n    var constructorInstance = instance;\r\n    if (!(object instanceof constructorInstance)) {\r\n        if (constructorInstance.name !== object.constructor.name) {\r\n            _fail(auth, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\r\n        }\r\n        throw _errorWithCustomMessage(auth, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */, \"Type of \".concat(object.constructor.name, \" does not match expected instance.\") +\r\n            \"Did you pass a reference from a different Auth SDK?\");\r\n    }\r\n}\r\nfunction createErrorInternal(authOrCode) {\r\n    var _a;\r\n    var rest = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        rest[_i - 1] = arguments[_i];\r\n    }\r\n    if (typeof authOrCode !== 'string') {\r\n        var code = rest[0];\r\n        var fullParams = __spreadArray([], rest.slice(1), true);\r\n        if (fullParams[0]) {\r\n            fullParams[0].appName = authOrCode.name;\r\n        }\r\n        return (_a = authOrCode._errorFactory).create.apply(_a, __spreadArray([code], fullParams, false));\r\n    }\r\n    return _DEFAULT_AUTH_ERROR_FACTORY.create.apply(_DEFAULT_AUTH_ERROR_FACTORY, __spreadArray([authOrCode], rest, false));\r\n}\r\nexport function _assert(assertion, authOrCode) {\r\n    var rest = [];\r\n    for (var _i = 2; _i < arguments.length; _i++) {\r\n        rest[_i - 2] = arguments[_i];\r\n    }\r\n    if (!assertion) {\r\n        throw createErrorInternal.apply(void 0, __spreadArray([authOrCode], rest, false));\r\n    }\r\n}\r\nvar Optional = /** @class */ (function () {\r\n    function Optional(type) {\r\n        this.type = type;\r\n    }\r\n    return Optional;\r\n}());\r\nexport function opt(type) {\r\n    return new Optional(type);\r\n}\r\n/**\r\n * Asserts the runtime types of arguments. The 'expected' field can be one of\r\n * a class, a string (representing a \"typeof\" call), or a record map of name\r\n * to type. Furthermore, the opt() function can be used to mark a field as\r\n * optional. For example:\r\n *\r\n * function foo(auth: Auth, profile: {displayName?: string}, update = false) {\r\n *   assertTypes(arguments, [AuthImpl, {displayName: opt('string')}, opt('boolean')]);\r\n * }\r\n *\r\n * opt() can be used for any type:\r\n * function foo(auth?: Auth) {\r\n *   assertTypes(arguments, [opt(AuthImpl)]);\r\n * }\r\n *\r\n * The string types can be or'd together, and you can use \"null\" as well (note\r\n * that typeof null === 'object'; this is an edge case). For example:\r\n *\r\n * function foo(profile: {displayName?: string | null}) {\r\n *   assertTypes(arguments, [{displayName: opt('string|null')}]);\r\n * }\r\n *\r\n * @param args\r\n * @param expected\r\n */\r\nexport function assertTypes(args) {\r\n    var expected = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        expected[_i - 1] = arguments[_i];\r\n    }\r\n    if (args.length > expected.length) {\r\n        _fail(\"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */, {});\r\n    }\r\n    var _loop_1 = function (i) {\r\n        var expect = expected[i];\r\n        var arg = args[i];\r\n        if (expect instanceof Optional) {\r\n            // If the arg is undefined, then it matches \"optional\" and we can move to\r\n            // the next arg\r\n            if (typeof arg === 'undefined') {\r\n                return \"continue\";\r\n            }\r\n            expect = expect.type;\r\n        }\r\n        if (typeof expect === 'string') {\r\n            // Handle the edge case for null because typeof null === 'object'\r\n            if (expect.includes('null') && arg === null) {\r\n                return \"continue\";\r\n            }\r\n            var required = expect.split('|');\r\n            _assert(required.includes(typeof arg), \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */, {});\r\n        }\r\n        else if (typeof expect === 'object') {\r\n            // Recursively check record arguments\r\n            var record_1 = arg;\r\n            var map_1 = expect;\r\n            var keys = Object.keys(expect);\r\n            assertTypes.apply(void 0, __spreadArray([keys.map(function (k) { return record_1[k]; })], keys.map(function (k) { return map_1[k]; }), false));\r\n        }\r\n        else {\r\n            _assert(arg instanceof expect, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */, {});\r\n        }\r\n    };\r\n    for (var i = 0; i < expected.length; i++) {\r\n        _loop_1(i);\r\n    }\r\n}\r\n/**\r\n * Unconditionally fails, throwing an internal error with the given message.\r\n *\r\n * @param failure type of failure encountered\r\n * @throws Error\r\n */\r\nexport function debugFail(failure) {\r\n    // Log the failure in addition to throw an exception, just in case the\r\n    // exception is swallowed.\r\n    var message = \"INTERNAL ASSERTION FAILED: \" + failure;\r\n    _logError(message);\r\n    // NOTE: We don't use FirebaseError here because these are internal failures\r\n    // that cannot be handled by the user. (Also it would create a circular\r\n    // dependency between the error and assert modules which doesn't work.)\r\n    throw new Error(message);\r\n}\r\n/**\r\n * Fails if the given assertion condition is false, throwing an Error with the\r\n * given message if it did.\r\n *\r\n * @param assertion\r\n * @param message\r\n */\r\nexport function debugAssert(assertion, message) {\r\n    if (!assertion) {\r\n        debugFail(message);\r\n    }\r\n}\r\n//# sourceMappingURL=assert.js.map","references":["/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/model/public_types.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/util/dist/index.d.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/model/auth.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/core/errors.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/core/util/log.ts"],"map":"{\"version\":3,\"file\":\"assert.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../../src/core/util/assert.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/node_modules/.cache/rollup-plugin-typescript2/placeholder/src/core/util/assert.d.ts","writeByteOrderMark":false,"text":"/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { Auth } from '../../model/public_types';\r\nimport { FirebaseError } from '@firebase/util';\r\nimport { AuthErrorCode, AuthErrorParams } from '../errors';\r\ndeclare type LessAppName<K extends AuthErrorCode> = Omit<AuthErrorParams[K], 'appName'>;\r\n/**\r\n * Unconditionally fails, throwing a developer facing INTERNAL_ERROR\r\n *\r\n * @example\r\n * ```javascript\r\n * fail(auth, AuthErrorCode.MFA_REQUIRED);  // Error: the MFA_REQUIRED error needs more params than appName\r\n * fail(auth, AuthErrorCode.MFA_REQUIRED, {serverResponse});  // Compiles\r\n * fail(AuthErrorCode.INTERNAL_ERROR);  // Compiles; internal error does not need appName\r\n * fail(AuthErrorCode.USER_DELETED);  // Error: USER_DELETED requires app name\r\n * fail(auth, AuthErrorCode.USER_DELETED);  // Compiles; USER_DELETED _only_ needs app name\r\n * ```\r\n *\r\n * @param appName App name for tagging the error\r\n * @throws FirebaseError\r\n */\r\nexport declare function _fail<K extends AuthErrorCode>(code: K, ...data: {} extends AuthErrorParams[K] ? [AuthErrorParams[K]?] : [AuthErrorParams[K]]): never;\r\nexport declare function _fail<K extends AuthErrorCode>(auth: Auth, code: K, ...data: {} extends LessAppName<K> ? [LessAppName<K>?] : [LessAppName<K>]): never;\r\nexport declare function _createError<K extends AuthErrorCode>(code: K, ...data: {} extends AuthErrorParams[K] ? [AuthErrorParams[K]?] : [AuthErrorParams[K]]): FirebaseError;\r\nexport declare function _createError<K extends AuthErrorCode>(auth: Auth, code: K, ...data: {} extends LessAppName<K> ? [LessAppName<K>?] : [LessAppName<K>]): FirebaseError;\r\nexport declare function _errorWithCustomMessage(auth: Auth, code: AuthErrorCode, message: string): FirebaseError;\r\nexport declare function _assertInstanceOf(auth: Auth, object: object, instance: unknown): void;\r\nexport declare function _assert<K extends AuthErrorCode>(assertion: unknown, code: K, ...data: {} extends AuthErrorParams[K] ? [AuthErrorParams[K]?] : [AuthErrorParams[K]]): asserts assertion;\r\nexport declare function _assert<K extends AuthErrorCode>(assertion: unknown, auth: Auth, code: K, ...data: {} extends LessAppName<K> ? [LessAppName<K>?] : [LessAppName<K>]): asserts assertion;\r\ndeclare type TypeExpectation = Function | string | MapType;\r\ninterface MapType extends Record<string, TypeExpectation | Optional> {\r\n}\r\ndeclare class Optional {\r\n    readonly type: TypeExpectation;\r\n    constructor(type: TypeExpectation);\r\n}\r\nexport declare function opt(type: TypeExpectation): Optional;\r\n/**\r\n * Asserts the runtime types of arguments. The 'expected' field can be one of\r\n * a class, a string (representing a \"typeof\" call), or a record map of name\r\n * to type. Furthermore, the opt() function can be used to mark a field as\r\n * optional. For example:\r\n *\r\n * function foo(auth: Auth, profile: {displayName?: string}, update = false) {\r\n *   assertTypes(arguments, [AuthImpl, {displayName: opt('string')}, opt('boolean')]);\r\n * }\r\n *\r\n * opt() can be used for any type:\r\n * function foo(auth?: Auth) {\r\n *   assertTypes(arguments, [opt(AuthImpl)]);\r\n * }\r\n *\r\n * The string types can be or'd together, and you can use \"null\" as well (note\r\n * that typeof null === 'object'; this is an edge case). For example:\r\n *\r\n * function foo(profile: {displayName?: string | null}) {\r\n *   assertTypes(arguments, [{displayName: opt('string|null')}]);\r\n * }\r\n *\r\n * @param args\r\n * @param expected\r\n */\r\nexport declare function assertTypes(args: Omit<IArguments, 'callee'>, ...expected: Array<TypeExpectation | Optional>): void;\r\n/**\r\n * Unconditionally fails, throwing an internal error with the given message.\r\n *\r\n * @param failure type of failure encountered\r\n * @throws Error\r\n */\r\nexport declare function debugFail(failure: string): never;\r\n/**\r\n * Fails if the given assertion condition is false, throwing an Error with the\r\n * given message if it did.\r\n *\r\n * @param assertion\r\n * @param message\r\n */\r\nexport declare function debugAssert(assertion: unknown, message: string): asserts assertion;\r\nexport {};\r\n"}}
