{"code":"/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { __awaiter, __generator } from \"tslib\";\r\nimport { _castAuth } from '../../core/auth/auth_impl';\r\nimport { _assertLinkedStatus } from '../../core/user/link_unlink';\r\nimport { _assertInstanceOf } from '../../core/util/assert';\r\nimport { _generateEventId } from '../../core/util/event_id';\r\nimport { _withDefaultResolver } from '../../core/util/resolver';\r\nimport { RedirectAction, _setPendingRedirectStatus } from '../../core/strategies/redirect';\r\nimport { FederatedAuthProvider } from '../../core/providers/federated';\r\nimport { getModularInstance } from '@firebase/util';\r\n/**\r\n * Authenticates a Firebase client using a full-page redirect flow.\r\n *\r\n * @remarks\r\n * To handle the results and errors for this operation, refer to {@link getRedirectResult}.\r\n * Follow the {@link https://firebase.google.com/docs/auth/web/redirect-best-practices\r\n * | best practices} when using {@link signInWithRedirect}.\r\n *\r\n * This method does not work in a Node.js environment.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a redirect.\r\n * const provider = new FacebookAuthProvider();\r\n * // You can add additional scopes to the provider:\r\n * provider.addScope('user_birthday');\r\n * // Start a sign in process for an unauthenticated user.\r\n * await signInWithRedirect(auth, provider);\r\n * // This will trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * if (result) {\r\n *   // This is the signed-in user\r\n *   const user = result.user;\r\n *   // This gives you a Facebook Access Token.\r\n *   const credential = provider.credentialFromResult(auth, result);\r\n *   const token = credential.accessToken;\r\n * }\r\n * // As this API can be used for sign-in, linking and reauthentication,\r\n * // check the operationType to determine what triggered this redirect\r\n * // operation.\r\n * const operationType = result.operationType;\r\n * ```\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.\r\n * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.\r\n * @param resolver - An instance of {@link PopupRedirectResolver}, optional\r\n * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.\r\n *\r\n * @public\r\n */\r\nexport function signInWithRedirect(auth, provider, resolver) {\r\n    return _signInWithRedirect(auth, provider, resolver);\r\n}\r\nexport function _signInWithRedirect(auth, provider, resolver) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var authInternal, resolverInternal;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    authInternal = _castAuth(auth);\r\n                    _assertInstanceOf(auth, provider, FederatedAuthProvider);\r\n                    // Wait for auth initialization to complete, this will process pending redirects and clear the\r\n                    // PENDING_REDIRECT_KEY in persistence. This should be completed before starting a new\r\n                    // redirect and creating a PENDING_REDIRECT_KEY entry.\r\n                    return [4 /*yield*/, authInternal._initializationPromise];\r\n                case 1:\r\n                    // Wait for auth initialization to complete, this will process pending redirects and clear the\r\n                    // PENDING_REDIRECT_KEY in persistence. This should be completed before starting a new\r\n                    // redirect and creating a PENDING_REDIRECT_KEY entry.\r\n                    _a.sent();\r\n                    resolverInternal = _withDefaultResolver(authInternal, resolver);\r\n                    return [4 /*yield*/, _setPendingRedirectStatus(resolverInternal, authInternal)];\r\n                case 2:\r\n                    _a.sent();\r\n                    return [2 /*return*/, resolverInternal._openRedirect(authInternal, provider, \"signInViaRedirect\" /* AuthEventType.SIGN_IN_VIA_REDIRECT */)];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**\r\n * Reauthenticates the current user with the specified {@link OAuthProvider} using a full-page redirect flow.\r\n * @remarks\r\n * To handle the results and errors for this operation, refer to {@link getRedirectResult}.\r\n * Follow the {@link https://firebase.google.com/docs/auth/web/redirect-best-practices\r\n * | best practices} when using {@link reauthenticateWithRedirect}.\r\n *\r\n * This method does not work in a Node.js environment.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a redirect.\r\n * const provider = new FacebookAuthProvider();\r\n * const result = await signInWithRedirect(auth, provider);\r\n * // This will trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * // Reauthenticate using a redirect.\r\n * await reauthenticateWithRedirect(result.user, provider);\r\n * // This will again trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * ```\r\n *\r\n * @param user - The user.\r\n * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.\r\n * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.\r\n * @param resolver - An instance of {@link PopupRedirectResolver}, optional\r\n * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.\r\n *\r\n * @public\r\n */\r\nexport function reauthenticateWithRedirect(user, provider, resolver) {\r\n    return _reauthenticateWithRedirect(user, provider, resolver);\r\n}\r\nexport function _reauthenticateWithRedirect(user, provider, resolver) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var userInternal, resolverInternal, eventId;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    userInternal = getModularInstance(user);\r\n                    _assertInstanceOf(userInternal.auth, provider, FederatedAuthProvider);\r\n                    // Wait for auth initialization to complete, this will process pending redirects and clear the\r\n                    // PENDING_REDIRECT_KEY in persistence. This should be completed before starting a new\r\n                    // redirect and creating a PENDING_REDIRECT_KEY entry.\r\n                    return [4 /*yield*/, userInternal.auth._initializationPromise];\r\n                case 1:\r\n                    // Wait for auth initialization to complete, this will process pending redirects and clear the\r\n                    // PENDING_REDIRECT_KEY in persistence. This should be completed before starting a new\r\n                    // redirect and creating a PENDING_REDIRECT_KEY entry.\r\n                    _a.sent();\r\n                    resolverInternal = _withDefaultResolver(userInternal.auth, resolver);\r\n                    return [4 /*yield*/, _setPendingRedirectStatus(resolverInternal, userInternal.auth)];\r\n                case 2:\r\n                    _a.sent();\r\n                    return [4 /*yield*/, prepareUserForRedirect(userInternal)];\r\n                case 3:\r\n                    eventId = _a.sent();\r\n                    return [2 /*return*/, resolverInternal._openRedirect(userInternal.auth, provider, \"reauthViaRedirect\" /* AuthEventType.REAUTH_VIA_REDIRECT */, eventId)];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**\r\n * Links the {@link OAuthProvider} to the user account using a full-page redirect flow.\r\n * @remarks\r\n * To handle the results and errors for this operation, refer to {@link getRedirectResult}.\r\n * Follow the {@link https://firebase.google.com/docs/auth/web/redirect-best-practices\r\n * | best practices} when using {@link linkWithRedirect}.\r\n *\r\n * This method does not work in a Node.js environment.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using some other provider.\r\n * const result = await signInWithEmailAndPassword(auth, email, password);\r\n * // Link using a redirect.\r\n * const provider = new FacebookAuthProvider();\r\n * await linkWithRedirect(result.user, provider);\r\n * // This will trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * ```\r\n *\r\n * @param user - The user.\r\n * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.\r\n * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.\r\n * @param resolver - An instance of {@link PopupRedirectResolver}, optional\r\n * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.\r\n *\r\n * @public\r\n */\r\nexport function linkWithRedirect(user, provider, resolver) {\r\n    return _linkWithRedirect(user, provider, resolver);\r\n}\r\nexport function _linkWithRedirect(user, provider, resolver) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var userInternal, resolverInternal, eventId;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    userInternal = getModularInstance(user);\r\n                    _assertInstanceOf(userInternal.auth, provider, FederatedAuthProvider);\r\n                    // Wait for auth initialization to complete, this will process pending redirects and clear the\r\n                    // PENDING_REDIRECT_KEY in persistence. This should be completed before starting a new\r\n                    // redirect and creating a PENDING_REDIRECT_KEY entry.\r\n                    return [4 /*yield*/, userInternal.auth._initializationPromise];\r\n                case 1:\r\n                    // Wait for auth initialization to complete, this will process pending redirects and clear the\r\n                    // PENDING_REDIRECT_KEY in persistence. This should be completed before starting a new\r\n                    // redirect and creating a PENDING_REDIRECT_KEY entry.\r\n                    _a.sent();\r\n                    resolverInternal = _withDefaultResolver(userInternal.auth, resolver);\r\n                    return [4 /*yield*/, _assertLinkedStatus(false, userInternal, provider.providerId)];\r\n                case 2:\r\n                    _a.sent();\r\n                    return [4 /*yield*/, _setPendingRedirectStatus(resolverInternal, userInternal.auth)];\r\n                case 3:\r\n                    _a.sent();\r\n                    return [4 /*yield*/, prepareUserForRedirect(userInternal)];\r\n                case 4:\r\n                    eventId = _a.sent();\r\n                    return [2 /*return*/, resolverInternal._openRedirect(userInternal.auth, provider, \"linkViaRedirect\" /* AuthEventType.LINK_VIA_REDIRECT */, eventId)];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**\r\n * Returns a {@link UserCredential} from the redirect-based sign-in flow.\r\n *\r\n * @remarks\r\n * If sign-in succeeded, returns the signed in user. If sign-in was unsuccessful, fails with an\r\n * error. If no redirect operation was called, returns `null`.\r\n *\r\n * This method does not work in a Node.js environment.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a redirect.\r\n * const provider = new FacebookAuthProvider();\r\n * // You can add additional scopes to the provider:\r\n * provider.addScope('user_birthday');\r\n * // Start a sign in process for an unauthenticated user.\r\n * await signInWithRedirect(auth, provider);\r\n * // This will trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * if (result) {\r\n *   // This is the signed-in user\r\n *   const user = result.user;\r\n *   // This gives you a Facebook Access Token.\r\n *   const credential = provider.credentialFromResult(auth, result);\r\n *   const token = credential.accessToken;\r\n * }\r\n * // As this API can be used for sign-in, linking and reauthentication,\r\n * // check the operationType to determine what triggered this redirect\r\n * // operation.\r\n * const operationType = result.operationType;\r\n * ```\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param resolver - An instance of {@link PopupRedirectResolver}, optional\r\n * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.\r\n *\r\n * @public\r\n */\r\nexport function getRedirectResult(auth, resolver) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, _castAuth(auth)._initializationPromise];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [2 /*return*/, _getRedirectResult(auth, resolver, false)];\r\n            }\r\n        });\r\n    });\r\n}\r\nexport function _getRedirectResult(auth, resolverExtern, bypassAuthState) {\r\n    if (bypassAuthState === void 0) { bypassAuthState = false; }\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var authInternal, resolver, action, result;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    authInternal = _castAuth(auth);\r\n                    resolver = _withDefaultResolver(authInternal, resolverExtern);\r\n                    action = new RedirectAction(authInternal, resolver, bypassAuthState);\r\n                    return [4 /*yield*/, action.execute()];\r\n                case 1:\r\n                    result = _a.sent();\r\n                    if (!(result && !bypassAuthState)) return [3 /*break*/, 4];\r\n                    delete result.user._redirectEventId;\r\n                    return [4 /*yield*/, authInternal._persistUserIfCurrent(result.user)];\r\n                case 2:\r\n                    _a.sent();\r\n                    return [4 /*yield*/, authInternal._setRedirectUser(null, resolverExtern)];\r\n                case 3:\r\n                    _a.sent();\r\n                    _a.label = 4;\r\n                case 4: return [2 /*return*/, result];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction prepareUserForRedirect(user) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var eventId;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    eventId = _generateEventId(\"\".concat(user.uid, \":::\"));\r\n                    user._redirectEventId = eventId;\r\n                    return [4 /*yield*/, user.auth._setRedirectUser(user)];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [4 /*yield*/, user.auth._persistUserIfCurrent(user)];\r\n                case 2:\r\n                    _a.sent();\r\n                    return [2 /*return*/, eventId];\r\n            }\r\n        });\r\n    });\r\n}\r\n//# sourceMappingURL=redirect.js.map","references":["/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/model/public_types.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/core/auth/auth_impl.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/core/user/link_unlink.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/core/util/assert.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/core/util/event_id.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/model/popup_redirect.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/model/user.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/core/util/resolver.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/core/strategies/redirect.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/src/core/providers/federated.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/util/dist/index.d.ts"],"map":"{\"version\":3,\"file\":\"redirect.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../../src/platform_browser/strategies/redirect.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/auth/node_modules/.cache/rollup-plugin-typescript2/placeholder/src/platform_browser/strategies/redirect.d.ts","writeByteOrderMark":false,"text":"/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { Auth, AuthProvider, PopupRedirectResolver, User, UserCredential } from '../../model/public_types';\r\n/**\r\n * Authenticates a Firebase client using a full-page redirect flow.\r\n *\r\n * @remarks\r\n * To handle the results and errors for this operation, refer to {@link getRedirectResult}.\r\n * Follow the {@link https://firebase.google.com/docs/auth/web/redirect-best-practices\r\n * | best practices} when using {@link signInWithRedirect}.\r\n *\r\n * This method does not work in a Node.js environment.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a redirect.\r\n * const provider = new FacebookAuthProvider();\r\n * // You can add additional scopes to the provider:\r\n * provider.addScope('user_birthday');\r\n * // Start a sign in process for an unauthenticated user.\r\n * await signInWithRedirect(auth, provider);\r\n * // This will trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * if (result) {\r\n *   // This is the signed-in user\r\n *   const user = result.user;\r\n *   // This gives you a Facebook Access Token.\r\n *   const credential = provider.credentialFromResult(auth, result);\r\n *   const token = credential.accessToken;\r\n * }\r\n * // As this API can be used for sign-in, linking and reauthentication,\r\n * // check the operationType to determine what triggered this redirect\r\n * // operation.\r\n * const operationType = result.operationType;\r\n * ```\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.\r\n * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.\r\n * @param resolver - An instance of {@link PopupRedirectResolver}, optional\r\n * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.\r\n *\r\n * @public\r\n */\r\nexport declare function signInWithRedirect(auth: Auth, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<never>;\r\nexport declare function _signInWithRedirect(auth: Auth, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<void | never>;\r\n/**\r\n * Reauthenticates the current user with the specified {@link OAuthProvider} using a full-page redirect flow.\r\n * @remarks\r\n * To handle the results and errors for this operation, refer to {@link getRedirectResult}.\r\n * Follow the {@link https://firebase.google.com/docs/auth/web/redirect-best-practices\r\n * | best practices} when using {@link reauthenticateWithRedirect}.\r\n *\r\n * This method does not work in a Node.js environment.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a redirect.\r\n * const provider = new FacebookAuthProvider();\r\n * const result = await signInWithRedirect(auth, provider);\r\n * // This will trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * // Reauthenticate using a redirect.\r\n * await reauthenticateWithRedirect(result.user, provider);\r\n * // This will again trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * ```\r\n *\r\n * @param user - The user.\r\n * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.\r\n * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.\r\n * @param resolver - An instance of {@link PopupRedirectResolver}, optional\r\n * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.\r\n *\r\n * @public\r\n */\r\nexport declare function reauthenticateWithRedirect(user: User, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<never>;\r\nexport declare function _reauthenticateWithRedirect(user: User, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<void | never>;\r\n/**\r\n * Links the {@link OAuthProvider} to the user account using a full-page redirect flow.\r\n * @remarks\r\n * To handle the results and errors for this operation, refer to {@link getRedirectResult}.\r\n * Follow the {@link https://firebase.google.com/docs/auth/web/redirect-best-practices\r\n * | best practices} when using {@link linkWithRedirect}.\r\n *\r\n * This method does not work in a Node.js environment.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using some other provider.\r\n * const result = await signInWithEmailAndPassword(auth, email, password);\r\n * // Link using a redirect.\r\n * const provider = new FacebookAuthProvider();\r\n * await linkWithRedirect(result.user, provider);\r\n * // This will trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * ```\r\n *\r\n * @param user - The user.\r\n * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.\r\n * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.\r\n * @param resolver - An instance of {@link PopupRedirectResolver}, optional\r\n * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.\r\n *\r\n * @public\r\n */\r\nexport declare function linkWithRedirect(user: User, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<never>;\r\nexport declare function _linkWithRedirect(user: User, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<void | never>;\r\n/**\r\n * Returns a {@link UserCredential} from the redirect-based sign-in flow.\r\n *\r\n * @remarks\r\n * If sign-in succeeded, returns the signed in user. If sign-in was unsuccessful, fails with an\r\n * error. If no redirect operation was called, returns `null`.\r\n *\r\n * This method does not work in a Node.js environment.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a redirect.\r\n * const provider = new FacebookAuthProvider();\r\n * // You can add additional scopes to the provider:\r\n * provider.addScope('user_birthday');\r\n * // Start a sign in process for an unauthenticated user.\r\n * await signInWithRedirect(auth, provider);\r\n * // This will trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * if (result) {\r\n *   // This is the signed-in user\r\n *   const user = result.user;\r\n *   // This gives you a Facebook Access Token.\r\n *   const credential = provider.credentialFromResult(auth, result);\r\n *   const token = credential.accessToken;\r\n * }\r\n * // As this API can be used for sign-in, linking and reauthentication,\r\n * // check the operationType to determine what triggered this redirect\r\n * // operation.\r\n * const operationType = result.operationType;\r\n * ```\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param resolver - An instance of {@link PopupRedirectResolver}, optional\r\n * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.\r\n *\r\n * @public\r\n */\r\nexport declare function getRedirectResult(auth: Auth, resolver?: PopupRedirectResolver): Promise<UserCredential | null>;\r\nexport declare function _getRedirectResult(auth: Auth, resolverExtern?: PopupRedirectResolver, bypassAuthState?: boolean): Promise<UserCredential | null>;\r\n"}}
